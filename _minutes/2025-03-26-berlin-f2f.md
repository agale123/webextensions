# 2025 WECG Berlin F2F, Public Notes, Mar 26

Wednesday, the second day of the four-day face-to-face meeting in Berlin (announcement: [#759](https://github.com/w3c/webextensions/issues/759)). Agenda: https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination


## Agenda

 * [Issue triage (Part 1)](#issue-triage-part-1)
   * [runtime.onInvalidated event and related](#runtimeoninvalidated-event-and-related)
   * [Issue 700: Declaring compatible websites (without prompting the user)](#issue-700-declaring-compatible-websites-without-prompting-the-user)
   * [Issue 756: Proposal: Exclude Matching](#issue-756-proposal-exclude-matching)
   * [Issue 701: Block extension from specific hosts](#issue-701-block-extension-from-specific-hosts)
 * [Platform Documentation](#platform-documentation)
 * [Finally Write a Spec?](#finally-write-a-spec)
 * [Extensions & AI](#extensions--ai)
 * [Browser Automation](#browser-automation)
   * [Issue 693: Add API to switch focus from sidePanel to main document to enable accessibility features](#issue-693-add-api-to-switch-focus-from-sidepanel-to-main-document-to-enable-accessibility-features)
   * [Accessibility trees](#accessibility-trees)
 * [Testing Sync](#testing-sync)
   * [wpt.fyi and interop](#wptfyi-and-interop)


## Attendees

 * Oliver Dunk (Google Chrome)
 * Devlin Cronin (Google Chrome)
 * Simeon Vincent (Mozilla)
 * Rob Wu (Mozilla)
 * Tomislav Jovanovic (Mozilla)
 * Carlos Jeurissen (Jeurissen Apps)
 * Mukul Purohit (Microsoft Edge)
 * Timothy Hatcher (Apple)
 * Maxim Topciu (AdGuard)
 * David Tota (AdGuard)
 * Kiara Rose (Apple)
 * Casey Garland (Capital One)
 * Jordan Spivack (Capital One)
 * Kees Kluskens (Tango)
 * Elijah Sawyers (Apple) - Testing Sync Only.


## Notes


### Issue triage (Part 1)

 * (10:00)


#### runtime.onInvalidated event and related

 * [carlos] Group of related topics
   * [Issue 138](https://github.com/w3c/webextensions/issues/138): Proposal: let content scripts listen for event to detect when the extension is unloaded (for various reasons)
   * [Issue 353](https://github.com/w3c/webextensions/issues/353): Support onEnabled event when the extension from disabled state to enabled state
   * [Issue 789](https://github.com/w3c/webextensions/issues/789): Proposal: runtime.onInvalidated.addListener
   * https://issues.chromium.org/issues/40384477
 * Discussion
   * [devlin] Discussed last year too; not much have changed on our positions - still supportive, no bandwidth to prioritize.
   * [carlos] Willing to create a proposal.
   * [oliver] We need a sponsoring browser.
   * [devlin] If Carlos is willing to do the hard work of the proposal, the actual implementation would be straightforward.
   * [timothy] Going forward we should try a more inclusive language than onEnabled/onDisabled. For example we use turned on/turned off at Apple.
   * [devlin] I renamed [Issue 138](https://github.com/w3c/webextensions/issues/138) for clarity. From: “Proposal: let content scripts listen for event chrome.runtime.onUninstalled”, To: “Proposal: let content scripts listen for event to detect when the extension is unloaded (for various reasons)”
   * **Action Item:** Carlos to create PR for issue 138 with Chrome as sponsoring browser.
 * Additional context added post meeting:
   * Carlos created PR https://github.com/w3c/webextensions/pull/792
   * Issue 138 and PR 792 are revisited on Thursday (Lifecycle & Matching topic).


#### [Issue 700](https://github.com/w3c/webextensions/issues/700): Declaring compatible websites (without prompting the user)

 * [oliver] I don't think that more manifest keys would help here.
 * [devlin] Agreed.
 * [timothy] Happy with the current approach. Not sold on a new key being the solution.
 * [devlin] I think the goal is more consistent UI across browsers. That's a browser problem, not a platform one. Safari currently withholds hosts and Chrome is working towards that.
 * [rob] Isn't addHostAccessRequest the general solution?
 * [devlin] We think so, yes.
 * [timothy] Agree. Unless we're renaming things in a manifest bump, the current names are fine.
 * [rob] addHostAccessRequest is a general way to do it in Chrome, could be added to Firefox, but doesn't seem like a solution in Safari.
 * [timothy] That's why we were kind of against that API; it's not possible to do in Safari.
 * [oliver] We settled on that URL taking URL patterns. That could work in Safari, right?
 * [timothy] I recall that now, could be useful.
 * [simeon] Next steps on this?
 * [devlin] Seems like Chrome and Safari are opposed. Firefox?
 * [rob] I see the intent. Should ask whether addHostAccessRequest would address this use case.
 * [rob] Another related issue is what to do with new extension permissions on update ([issue 711](https://github.com/w3c/webextensions/issues/711)). A general solution could cover both issues.
 * [devlin] I'll work on a reply.
 * **Resolution:** Close issue 700, Chrome and Safari are opposed.


#### [Issue 756](https://github.com/w3c/webextensions/issues/756): Proposal: Exclude Matching

 * [carlos] Basically the proposal is for negative match patterns. Either an explicit exclude match list or some kind of negative pattern (prepending exclamation mark `!` before match pattern).
 * [timothy] Clever approach. Not sure we'd go out of our way to add it if exclude isn't already supported by a given API.
 * [carlos] Only cover it in existing APIs that have exclude matches?
 * [timothy] If we support it at all, it could be included anywhere. Could potentially replace existing exclude_matches. Don't see a clear demand to introduce this syntax to match patterns. Currently neutral. Could keep in our pocket in case we need it
 * [rob] Seems like it could be useful. I largely agree with Timothy. In cases where we don't have exclude, we could introduce this syntax. If we want to introduce this, we could stop erroring now and eventually, once we have enough support in historical versions, we could actually adopt it.
 * [oliver] Okay, we're talking about new syntax, not a new key.
 * [rob] Correct.
 * [timothy] I was gravitating to syntax, yes.
 * [devlin] I see two questions. Do we want to allow this as syntax vs. a key, and what the syntax would be.
 * [rob] If we adopt a syntax, we can apply this logic across all APIs that take a set of match patterns, without requiring separate exclude keys in each API.
 * [devlin] Sounds like an implementation detail. In Chrome we have  UrlPatternSet. That code would be invalid if we introduce the concept of negation.
 * [timothy] We have a match pattern class too, but we don't have a set that covers the whole set.
 * [devlin] The idea that this will magically work in all cases is heavily browser specific.
 * [rob] Right, would need to be audited and tested for support.
 * [devlin] If we're auditing every API, it's orthogonal to changing this one piece. Whether we change the syntax to allow negation or introduce exclude matches, those don't have to be directly linked. Is there a reason they have to be linked or can we discuss separately?
 * [rob] If we prefer one over the other, we can skip implementing the other. Less total work.
 * [devlin] That's only a point for the syntax, not the negation.
 * [rob] Current title is “exclude matching”, you're suggesting we split negation out into a separate issue?
 * [devlin] Not necessarily. Do all browsers agree that it's a good idea to include exclude matches in more places?
 * [carlos] Syntax and excludes are potentially different in what they can cover.
 * [oliver] Agree we should support exclusion in more places.
 * Agreement from all browsers.
 * [devlin] Sounds like we're generally supportive of this use case, but how we do it still needs discussion. Any browsers that would immediately leap on this (next 3 months)?
 * [rob] Don't see a big need demanding that speed.
 * [timothy] Same.
 * [oliver] contentSettings API also uses match patterns where a negation syntax would be strange, especially in the UI associated with it.
 * [rob] Neither Firefox nor Safari have this API.
 * [devlin] In Chrome this wouldn't work. That wouldn't support exclude matches today and it would be hard to support.
 * **Resolution:** Chrome, Firefox, Safari in favor of supporting exclude of match patterns across APIs; the exact mechanism is still up for discussion, in issue 756.


#### [Issue 701](https://github.com/w3c/webextensions/issues/701): Block extension from specific hosts

 * [simeon] Seems like this is related to the previous discussion.
 * [oliver] … Would be difficult to communicate this setting to users.
 * [timothy] The request is removal after the fact, your description makes it sounds like an install time feature.
 * [oliver] Yes, but there are still concerns around communicating that access revocation to users.
 * [rob] Letting the extension drive this could cause confusion. Proposal states that the browser can do this, which is true, for example with enterprise policies. Concerned about exposing this data to extensions as it may leak information the enterprise doesn't want to expose to extensions.
 * [timothy] We have a tristate for host permissions, can ask, not granted, granted. Allow grants host permission, Deny is “not granted” (what this issue calls “blocked”).
 * [rob] Would you be supportive of the extension changing “never ask again” to “ask again”? That is what the second part of the issue is asking for.
 * [timothy] Don't necessarily agree with that. Don't want the extension to see what's blocked outside of the extension's own requests to block. But I'm okay with the idea of the extension putting something into the deny list and allowing users to change that later.
 * [devlin] here we're talking about a block/deny list on a per-extension basis. (timothy: yes) Would there be any reason for a user to modify that list? Don't see a reason to allow a user to force an extension to have access to a site. Agree with concerns around leaking data for blocked sites to the extension. I see this request as affecting the extension's requested sites, not the user's choices. Allowed sites are the intersection between permissions requested by the extension and granted by the user. I think I'd rephrase this request in a couple ways. Start with Carlos' previous proposal for disallowed permissions in the manifest. Follow on that to allow the Permissions API to dynamically add entries to that list.
   * [Issue 123](https://github.com/w3c/webextensions/issues/123): Proposal: add disallow_host_permissions
 * [timothy] That description matches what I had in mind when I added the supportive label.
 * [rob] This is a case where negation may be useful, right?
 * [devlin]I think in MV4 we make permissions a dictionary. I don't think having a “not” would be very helpful. Adding and removing entries in the blocked set isn't too useful.
 * [rob] How would this help a user?
 * [devin] User doesn't have anything to do with this IMO. As I see it, my tweaked version of this proposal only affects what the extension asks to run on.
 * [timothy] It's really useful for an extension that asks for everything and wants to restrict down to places it knows it doesn't want to run. Example: shopping extensions.
 * [casey] We work hard to not track things we're not supposed to. Ideally a user could inspect things to verify.
 * [rob] So this is more about dropping permissions (good practice). Because there is no good way to surface this information to users, because an extension update can always remove items from this list.
 * [devlin] I see this as more of a CSP-style principle.
 * [oliver] I like that CSP is entirely hidden from users. Not sure if we should have something like this shown in extension UI. Don't want a race of longer exclusion lists.
 * [devin] Don't think we'd include this at first. Want to avoid situations where removing an exclusion creates a permission request. If we show the user this info, then we'd have to do that.
 * [timothy] We don't currently show denials. Internally, we'd approach this as a denial that we don't show.
 * [casey] Would like a way for power users to verify.
 * [devin] Yes, see the utility for an admin or a regulator
 * [devlin] Wrapping up
 * [timothy] I'd be in favor of closing this in favor of [issue 123](https://github.com/w3c/webextensions/issues/123).
 * [devin] See value in making sure we cover this case. As long as we update 123 to include this case, I'm good with closing.
 * [maxim] See potential in having this API.
 * **Resolution**: Close issue in favor of issue 123, the “do I have access” part of the request will be covered by an issue Carlos is going to file.
(11:00 - break)


### Platform Documentation

 * (13:30)
 * [timothy] Can we align on MDN as the browser-neutral, authoritative documentation source? Let's talk about browser-specific API docs, how we cover cross-browser topics, and leveraging extensions (e.g., Rob's) to improve BCD data.
 * [simeon] Which extension?
 * [rob] I created a tool in the past to auto-generate the set of supported APIs in Chrome: https://github.com/mozilla/webextension-polyfill/pull/122
 * [brian] I'm Brian, a technical writer on the MDN team. We're looking at the extensions docs and we're currently doing a big reorganization. Good time to look at WebExt docs.
 * [vadim] Also tech writer on MDN, joined half a year ago. See that current documentation is Firefox-focused. Especially with support from different vendors.
 * [simeon] On the content operating side, Richard Bloor on our side handles writing WebExtensions content in MDN. I'm hoping to spend some more time this year on approaching the documentation process.
 * [simeon] How much interest is there on aligning on MDN as the browser-neutral authoritative source for WebExtensions documentation?
 * [timothy] We are interested. We are at least updating BCD data for Safari, and getting content into the articles.
 * [rob] With regard to content being Firefox focused, we try to be browser neutral. When there are cross-browser differences that I know of, we try to integrate them into the content updates. I believe Safari is primarily relying on MDN and BCD documentation. My impression is that Chrome would like to keep the c
 * [devlin] We continue to need a place for Chrome-specific documentation that MDN does not want/need to host, e.g. ChromeOS-specific platform apps. For API-specific bits we are open to either MDN or developer.chrome.com or some combination. Currently we auto-generate lots of documentation from IDL files and schemas from Chrome, that pipeline is very useful.
 * [oliver] Wondering if there are things, e.g. labels or things we need to monitor. A vision/roadmap on what you want would also be useful.
 * [oliver] When I spoke internally earlier, a concern was about a lot of work and changes overnight; we are willing to discuss and consider changes.
 * [simeon] Can the MDN folks speak to the current process of getting contributions from browser vendors.
 * [vadim] Neutrality, e.g. calling it WebExtensions (not “Firefox extensions” or “Chrome extensions”). We also have code owners, and automation to assign topics to specific reviewers (e.g. svg experts, JavaScript experts).
 * [vadim] One challenge is, on the web we have a common spec and slight deviations; in WebExtensions there are more differences.
 * [devlin] There are also a number of APIs that are not Chrome OS-specific, but also supported on other platforms, but not available in other browsers. For these APIs, do you envision documentation on MDN?
 * [vadim] We have a policy that any API available in stable browsers can be documented on MDN. We already have  bunch of Chrome-specific web platform APIs on MDN.
 * [simeon] In the WECG we have it as a part in our founding principles (charter) that browser vendors can deviate.
 * [simeon] In Firefox, MDN is our only site for extension API references. At least the way I think about it, we need a way with Firefox-specific content. I find it reasonable to extend that to browser-specific APIs.
 * [rob] Because of the existence of cross-browser differences, it may be difficult for extension developers to figure out what they can use for the browsers they target. BDC may cover that, but it requires the reader to consciously jump to the table. If they are not aware, at worst they may ship something that unexpectedly breaks in a browser. Is there any plan to improve the visibility of WebExtensions compatibility info in the API articles?
 * [vadim] Project in mind to make compatibility more visible, mostly part of Baseline. We already show baseline on many pages.
 * [rob] Extension APIs have methods and individual properties whose availability varies by browsers. It would be very useful if developers can see at a glance whether specific methods/properties are supported, without requiring the reader to consciously scroll to the Browser Compatibility table data.
 * [vadim] We don't have that yet, but are open to supporting it.
 * [tomislav] Not sure I understand the reference to Chromium-specific APIs that already exist on MDN. Are they on standards track?
 * [vadim] We don't document things that aren't on standards track. These wouldn't be APIs that are created for a specific browser with no intent for cross-browser implementation.
 * [devlin] For the purpose of this discussion, there is no spec.
 * [vadim] Usually every documented web platform feature has a spec. Does not need to be an official W3C spec, and authoritative documentation would also work.
 * [simeon] On guides, me and Richard would focus primarily on Firefox-specific documentation. Other browsers would have to contribute their part.
 * [timothy] Makes sense. I'm willing to contribute from the Apple side. Jon Davis is also willing.


### Finally Write a Spec?

 * (14:00)
 * [timothy] Should we take a WHATWG-style approach — write down what browsers do, use that to identify inconsistencies, and iteratively evolve it into a formal spec? What would it take to get there?
 * [simeon] What is the WHATWG-style approach?
 * [rob] I have only seen the output (the spec), not the process behind.
 * [simeon] In abstract I like it, but I don't know how it went there.
 * [timothy] I don't know either, my understanding is writing down what everyone did, of the current behavior, not necessarily the desired behavior, and then hashed it out with notes, inconsistencies, all these things. More a documentation effort than a “what it should be” effort.
 * [oliver] When we discussed this before, I thought that we decided to focus on what most browsers do, not literally everything that any browser does.
 * [timothy] I think a big driver of our spec work will probably be our tests. As we write tests, build out the spec, identify inconsistencies, clarify intended behavior, etc.
 * [tomislav] I think that's part of the history of how WHATWG got started. I think that would be very useful. Going forward we can ask not just documentation of corner cases, but also tests for them.
 * [devlin] One of the open questions from my point of view is how explicit do we want to be when defining the behavior. How specific do we want to get with browser behavior and features? Depth- or breadth-first approach? If we go for breadth, that will look very different from what other specs look and feel like.
 * [rob] Laying down a skeleton seems appealing, but also limits the utility of the specs.
 * [devlin] If we try to produce W3C style specs, that's a lot of work.
 * [tomislav] What you see in the specs today isn't where they started. They ended up here after a lot of iteration and discussion to resolve inconsistencies. They all grew naturally as an increased level of detail came to light.
 * [devlin] Worried about our collective velocity. If we try to go deep, that will take a lot of energy. If we go broad, will we be providing the level of detail developers expect? Will it have the level of validity expected from W3C specs?
 * [timothy] I am fine with a breadth-first approach. The example of “create a tab” leaves open a lot for interpretation, but “tabs.create” also has multiple properties that can meaningfully be described.
 * [devlin] I expect there will always be that level of interpretation, but say parse the URL and if there's an error throw.
 * [rob] Having that is easier to clarify than to write something from scratch.
 * [oliver] Does not have to be completely breadth-first; specific cases can be elaborated during specification.
 * [devlin] My main concern is still velocity.
 * [oliver] Velocity is a good concern, but I'm more worried about usefulness than trying to go too quickly and ending up with a copy of MDN.
 * [devlin] In that case, how do we ensure that there is progress? (all: not great) The parts that we do have are well-specified (e.g. content scripts). How do we ensure progress?
 * [timothy] Smaller PRs, faster turn-arounds would enable faster iterations.
 * [oliver] What you said seems contrasting to depth-first, but they can be complementary.
 * [timothy] Be detailed, but do not let it block the completion of a PR.
 * [devlin] Not concerned about the ability to write something useful for anything. I'm concerned about the extension platform producing something useful in the next decade.
 * [timothy] We need something substantial for a WG.
 * [oliver] Does anyone feel that the detail stops them from getting started?
 * [devlin] I'm not put off, but think that it takes times.
 * [tomislav] Content script example, is that a right level of detail?
 * [devlin] There are tradeoffs. There are things we've glossed over, but overall it was pretty good. And it took a year. Question is which is more valuable: covering more or hitting this level of thoroughness?
 * [tomislav] Timothy, you were the newest implementation. What was the most helpful and what were the most challenging missing pieces?
 * [timothy] We relied on Chrome's docs and MDN, and testing in various browsers to figure out what to do.
 * [rob] And there are so many layers and indirections in Chromium. I don't think the level of detail is the primary roadblock. If we have limited time, the question is where we spend it. … is a very good first step. If we put in investment up front, that sets us up to be more productive in the end.
 * [oliver] Devlin mentioned that changing the level of detail may 4-5x the number of submissions. That's true, but that might only take us from one to four or five PRs. We really need to focus more on how we find more time to write more.
 * [rob] Not one size fits all. Where it matters we should spend more energy on level of detail.
 * [oliver] We discussed `background.preferred_environment` in the leads meeting, we should write that up sooner than later.
 * [rob] Also okay to sometimes leave a notice stating that there are subtleties involved to watch out for, to be specified later.
 * [timothy] I can take on `preferred_environment`. Should be able to make some time in the next month.
 * [rob] Are we aligned on where to start?
 * [devlin] Not quite yet. I don't have a strong opinion about which strategy to pursue. We've been saying for years we should spec more. I'm wondering if there's something concrete that we should change or try to produce more.
 * [rob] IMO prerequisite is to have WPT. Allows someone to create tests, see how it behaves everywhere, write that down.
 * [devlin] Agree that WPT is helpful, but worried about trying to solve the need to write more spec by adding a dependency on writing tests.
 * [kiara] Would be helpful to list out what we want to have written. Even now it's unclear what the goal is by the end of the year. Maybe just list out 5 areas we want to attack, have a sponsored browser to write those areas.
 * [simeon] If it is not someone's deliverable, it is not going to be delivered.
 * [timothy] I'll take on the background area. `preferred_environment` is directly related to the rest of the `background` key. Focusing on the manifest is probably best. Can't have an extension without a manifest. Suggest others take on other manifest keys.
 * [rob] Have we written down our intent to not produce hard errors unless absolutely necessary?
 * [simeon] It's not in our spec.
 * [devlin] That's a bit hard to write down. Doesn't reflect the reality of Chrome.
 * [rob] We expressed this aspiration on error handling before, and universally have allow unrecognized keys at the top level.
 * [timothy] That's the WHATWG approach, document the reality, not the aspiration.
 * [mukul] We can follow what Rob is suggesting - use tests to drive spec.
 * [devlin] Don't want to block on tests.
 * [mukul] Agree there, but they can augment and assist.
 * [tomislav] Going back to Kiara's proposal, let's try to agree on a few items that we should document and spread out. `host_permissions` seem like another major important area to cover. If we could come up with a few more items before the end of the year.
 * [oliver] How do we feel about user gestures?
 * [rob] We have some (common) baseline of the concept of user gesture requirement, but there are also aspects that differ (e.g. duration of validity).
 * [oliver]  Agree we should document reality, but if we have simple things we can address as we spec, then we should do that.
 * [devlin] That's documenting reality – we're making those changes true. With regard to user gesture, my concern is that right now if we exclude expensive code changes, we'd be limited to saying “a user did a thing.”
 * [timothy] I think we'd have less disagreement there than you expect.
 * [rob] See value in writing down what we have, then we can iterate on that to introduce improvements.
 * [devlin] I'm fully supportive of someone working on this as long as it's not me. Have we done anything on extension origins?
 * [oliver] We have a header and no content below it.
 * [tomislav] Permission concepts is also a good candidate. I'll take that.
 * [timothy] name, version, description
 * [rob] To get something, we need to commit.
 * **Action Item:** Timothy to add background to the spec
 * **Action Item:** Tomislav to add permissions to the spec


### Extensions & AI

 * (14:35)
 * [simeon] “Discussion on experimental AI-related extension APIs that Chrome and Firefox have been trialing.”
 * [devlin] This category is broad, what do we want to discuss?
 * [timothy] Added this as both Firefox and Chrome are experimenting here. Are we in a alignment on naming? Are they still trials? Are we potentially moving AI stuff into a new surface/namespace in extensions?
 * [rob] To answer that, the feature set needs to be somewhat stable. My impression is this is iterating quickly right now. Correct?
 * [tomislav] Me and Tarek (from the machine learning (ML) team at Mozilla) have had some chats with Chromium folks. There is no consensus within browsers, and extension teams are not the owners of the features. Not sure we're in a position to mediate discussions. They're  already in direct contact. Don't think we can mediate alignment in the near future.
 * [rob] So what can we do?
 * [tomislav] We can try to make it not hard to be compatible with both or either.
 * [simeon] I think we should have a recommendation on how APIs are exposed in extensions.
 * [devlin] What APIs? In trials? APIs intended for the web platform? I don't think we necessarily need or want to have an opinion about how these are exposed.
 * []
 * [devlin] Thinking that trial APIs should be under the regular namespace to avoid prefix issues.
 * [tomislav] For us, `trial.ml` API is behind `trial` because we're not sure this is the final API we want to ship.
 * [devlin] There are APIs we've built for AI data collection that we have no intent to ship. Having those separated out by namespace makes sense. Question is is this intended to be a temporary or permanent restriction.
 * [tomislav] Not entirely comfortable with that. If someone came to you and said ‘we intend to launch this on standards track for the web, but we want to prototype in extensions' would you recommend that be namespaced or not? How would you approach that?
 * [devlin] In that case, I'd say build it out like you would for the web and restrict it to extensions.
 * [tomislav] Okay, that makes sense to me. I'd have similar guidance.
 * [devlin] The way extensions APIs are built and the way web APIs are built are very different.
 * [rob] To make sure that we are about the same thing: by “build like the web” you mean following the web conventions, such as `xxx.onmessage =` instead of `xxx.onMessage.addListener()` .
 * [devlin] Yes. If you end up bringing it to the web, then you end up introducing massive changes. If you end up not bringing it to the web, that's okay. Extensions use web-like things even if they're originally intended explicitly for extensions.
 * [rob] And not exposing them on the `browser` namespace, right?
 * [devlin] If you want it on the web, `browser` does not exist. But that's my perspective. And to Tomisalv's point, we don't own these APIs.
 * [rob] Any extension developer participants here that have questions/comments on the AI topic?
 * [oliver] Note that the next topic is about browser automation, which looks like it covers potential AI/agent use cases.
 * [tomislav] … with the trial.ml namespace, one of the intentions was that this won't exist for the next decade.
 * [devlin] The point of origin trials is that we'll experiment and things _will_ break. If it is something that you have no intention of shipping, that's when I'd say a separate namespace is best.
 * [oliver] To Devlin's point, we have `chrome.aiOriginTrial`
 * [devlin] Developer has to opt into it. It's restricted but limitless.
 * [oliver] We should spec the `trial_tokens` key.
 * [rob] Did I hear a volunteer?
 * [oliver] I can do that.
 * [timothy] Should be relatively easy to specify.
 * [oliver] We can say it's an array of strings. Beyond that, not much to say.
 * (discussion of things that could be specified)
 * [tomislav] I'll take an action item for what we can do in Mozilla, because unlike Google, Mozilla does not have a self service trial model.
 * [devlin] Oliver, can you test as if you had an origin trial?
 * [oliver] You can generate your own token.
 * [devlin] Waiting to get a live origin trial that you can use in an extension is less useful than having a way to start experimenting immediately.
 * [oliver] You can mint your own token using the steps here: https://chromium.googlesource.com/chromium/src/+/main/docs/origin_trials_integration.md#manual-testing
 * [devlin] What's Safari's support for origin trials?
 * [kiara] I don't think that we support origin trials.
 * [timothy] We have locally turned-on feature flags only.
 * [devlin] Would be good if we have somewhat consistent support for origin trial-like things. I have a preference for origin trials, as it was built for this exact use case.
 * [timothy] Not against it, we just don't have anything that would use it right now.
 * [devlin] Might be good to have a lighter weight way to have the same kind of thing as origin trials for extensions.
 * [timothy] I think if we wanted to do it, we could have origin trials for extension purposes. We haven't intended to ship any experiments like that yet.
 * **Action Item:** Tomislav to check how trial_tokens ([issue 454](https://github.com/w3c/webextensions/issues/454)) can be supported in Firefox.
 * **Action Item:** Oliver to add trial_tokens to the spec.


### Browser Automation

 * (15:15)
 * [simeon] In a recent conversation with Brian Shultz (CTO of Tango), he suggested that we consider discussing browser automation and agentic client use cases. In short, tools like [Browser Use](https://browser-use.com/) have taken off recently. From that tool's announcement Show HN post:

   > [Browser Use] allows you to build agents that interact with web elements using natural language prompts. We created a layer that simplifies website interaction for LLMs by extracting xPaths and interactive elements like buttons and input fields (and other fancy things). This enables you to design custom web automation and scraping functions without manual inspection through DevTools.
 * [simeon] Potential overlap with accessibility (exposing accessibility tree to extensions)
 * [kees] (Tango) Some of the things we want to do in Chrome extensions are painful; in browser use, the DOM needs to be processed (e.g. exclude hidden / non-interactive elements) to extract as much context as possible. We call it “simplified DOM”. We use `document.elementsFromPoint(x,y)` , which does not reveal elements outside the viewport. It would be useful to more accurately detect relevant elements on the page.
 * [rob] How would the browser know what is relevant to the extension?
 * [kees] For example, you don't want to expose elements that aren't visible and interactive to the user. Every automation tool will need to build something like this.
 * [kees] Another area is simulating clicks and keypresses; we currently use the `chrome.debugger` API for it, and don't like the prominent notification bar (infobar) shown to the user.
 * [rob] For this, you're asking if it would be possible to simulate trusted clicks or user interactions, correct?
 * [kees] Yeah. Essentially every automation extension will need to do something like this. `chrome.debugger` is very powerful and overkill for this kind of use case. You'd just want to simulate clicks and keypresses.
 * [rob] I've also built a number of extensions that simulate these events with DOM APIs (`.click()`, `.value`, dispatchEvent, etc.). Why is dispatching simulated events insufficient?
 * [kees] There are some very nuanced events you need to simulate if you want to do that work across all web pages.
 * [timothy] A lot of this overlaps with WebDriver.
 * [kees] It's not available in an extension, right?
 * [rob] The debugger API exposes a subset of WebDriver functionality. Firefox doesn't support it. I don't think Safari does either.
 * [timothy] WebDriver has all of that.
 * [kees] That is separate software; we want to run within the browser.
 * [timothy] I can run a WebDriver session with Safari; it is not an extension but does not have to be an extension.
 * [simeon] It may help to show how Tango has evolved into desiring this functionality.
 * [kees] Tango makes it easy for people to develop workflows; users can share workflows with others, and the extension can execute these workflows to automate certain actions. Currently it requires full access to the debugger API.
 * [simeon] Tango product originally targeted capturing workflows; later they took the captured steps and replays the workflows to automate most of the workflows where needed.
 * [timothy] I get it. This might be a situation where we want to expose the extension functionality through the extension APIs. But that capability is super sensitive. We currently expose webdriver behind bio-auth.
 * [rob] I see both the power and danger, and the desire to only use a small subset of that API. If we want to get anywhere with this, I think the most concrete step is to identify the common subset of webdriver that we'd want to expose, then work with our internal teams to safely expose those capabilities.
 * [timothy] WebDriver is a RPC-style API. It's completely different from the general usage pattern of existing WebExtensions APIs.
 * [rob] If the capabilities we expose are a subset of the protocol and a subset of what extensions can already do, it may be enough.
 * [timothy] Not sure if we'd have much interest in that.
 * [oliver] Regardless of what we do, having that background information on the subset of capabilities would be useful for possible future work. Also complicated because we don't have a BiDi implementation directly within Chrome. We have ChromeDriver commands that invoke Chrome DevTools Protocol capabilities.
 * [rob] Would you prefer dedicated extension APIs that build upon the same internals over exposing WebDriver-bidi?
 * [timothy] Yes. I can see us reimplementing a set of APIs that are designed for this. Don't want to even entertain the idea of using the developer tools APIs.
 * [kees] To be clear, I do not necessarily want the debugger API, it is just the only available method available currently. It has too many capabilities that I do NOT want (along with a warning bar).
 * [timothy] What we'd need is a better picture of the API surface you'd need. Clicking, scrolling, etc.
 * [devlin] Concern about the possibility of feature creep. Just adding a click API may sound easy; looking through the set of different parameters, there is a ton.
 * [timothy] We'd be reinventing WebDriver with a different API surface. Why can't this case be served with WebDriver?
 * [rob] Barrier to entry is much higher for a native application.
 * [timothy] This would be introducing a parallel version of webdriver with all of it's complexities and subtleties.
 * [devlin] We use clicks for more than just the web page thinking there's a user gesture. It's a signal of trust. There are APIs, permissions, browser capabilities, etc. behind user gestures. If an extension can simulate that perfectly…
 * [rob] Are you interested in true clicks, or basically “enough” for web pages to think that a click was simulated?
 * [kees] Fully understand the concerns about completely simulating the user gestures. We do not need event.isTrusted.
 * [devlin] Content script injection requires a user gesture. But for some of your flows, if a user clicks something you may need to replicate the set of user gestures to identically replay the interactions.
 * [timothy] Sounds like we may need to put this behind bio-auth in Safari.
 * [rob] With all these concerns, how would accessibility tools work?
 * [tomislav] They use natively installed software.
 * [timothy] And there are a lot of scary prompts to install them.
 * [devlin] And some OSs have canonically supported tools.
 * [oliver] Would also like to talk about accessibility trees.
 * [devlin] Automating user interaction has a lot of value, but it does not necessarily have to be an extension that solves this. An extension with this level of power would be very scary.
 * [simeon] I don't think that we necessarily have to implement all of this, it may be enough to set `event.isTrusted=true`.
 * [rob] I don't even think that it is necessary to have `isTrusted=true`; from experience of writing these kinds of extensions, the difficulty is that many websites have different expectations on the results of user interaction.
 * [simeon] `event.isTrusted` came to mind because it is a property that scripts can filter on. As I see it, the
 * [rob] I don't think isTrusted is the key (which can already be done by extensions, e.g. by overriding prototypes), I think easily simulated the entire set of events is.
 * [kees] And we could do it today using the debugger APIs, but that's too much power. We don't want that.
 * [devlin] `window.open` requires a user gesture.
 * [timothy] Another example is video playback with audio.


#### [Issue 693](https://github.com/w3c/webextensions/issues/693): Add API to switch focus from sidePanel to main document to enable accessibility features

 * [kees] One more question; moving focus from the sidepanel to the web page. How to get that further along?
   * [rob] We have discussed this topic at last year's TPAC (issue 693): https://github.com/w3c/webextensions/blob/main/_minutes/2024-09-24-wecg-tpac.md#discussed-issues
   * [Issue 693](https://github.com/w3c/webextensions/issues/693): Add API to switch focus from sidePanel to main document to enable accessibility features
 * [devlin] From the conceptual point of view I am amenable to that. It's mainly a matter of prioritization and resources.
 * [oliver] This is in our potential list of issues for Google Summer of Code.


#### Accessibility trees

 * [oliver] Accessibility trees! Currently half a dozen or so ways of getting it: debugger API, behind a flag to enable the Accessibility API (private API), experimental AI data API may also expose it. There are lots of ways of doing this. With folks working on AI projects, this seems like there might be some more general use here.
 * [tomislav] I don't think there's much interest in exposing these generally as it's not a public API. The tree itself is not well specified and is subject to change. The Browser Testing and Tools group (which works on WebDriver) is also responsible for that. Is there a shared shape of the tree?
 * [tomislav] Don't think so.
 * [simeon] Every browser has their own implementation.
 * [rob] Shared concept, but different details per browser. Similar to debugger API discussion, could expose a shared wire format.
 * [oliver or devlin] I would like a more API-shaped.
 * [rob] Chrome already has `accessibilityPrivate`; if the functionality has general utility, why is it then not exposed?
 * [devlin] It is an internal implementation detail of the browser.
 * [oliver] From what I have seen on what people are building, they may be comfortable with not-a-real-API and updating the extension to keep up with changes.
 * [devlin] I'm concerned that if we expose this as a higher-level thing, that developers expect consistency.
 * [timothy] Agreed.


### Testing Sync

 * (16:00)
 * [simeon] How do we get WPT testing across the finish line? Writing tests, getting them running on WPT.fyi, and aligning toward 2026 interop.
 * [timothy] We have made a lot of progress; I'll hand it over to Kiara and Elijah who work on this.
 * [kiara] PR in WPT to load and unload extensions through WebDriver (and RFC). Currently waiting for review.
   * WPT PR: https://github.com/web-platform-tests/wpt/pull/50648
   * RFC PR: https://github.com/web-platform-tests/rfcs/pull/219
   * ([rob] ^ is this the main PR you're referring to?)
 * [kiara] A goal on our end is to be involved in interop 2026. Ideally extensions would be a focus area.
 * [simeon] I'm interested in digging more into interop.
 * [kiara] I think they discuss topics near the end of the year.
 * [timothy] If we're not ready for interop 2026, we could go for an “active investigation area.” A lower stakes, but good to make progress on approach.
 * [tomislav] Quick status update on the Firefox side: I've successfully implemented this on top of the Safari patch that executes the current tests. One issue on top of the current design is that in the current PR, the browser.test event listener is only added after the promise for loading an extension is resolved. Currently relies on the parent page closing – not sure that's a strong enough guarantee on the origin of the events.
 * [kiara] What we do on our end is queuing messages until loading has happened.
 * [tomislav] I implemented queuing as well; the question is what we should queue etc. E.g. if we run a second test, should the queued message count.
 * [rob] … Let's table these details for PR discussion and the regular testing sync that we have, and focus today's meeting on the higher-level strategy?
 * [oliver] Curious if I missed it. Is there a reason you can't register the test before?
 * [tomislav] You don't know the extension ID before you load the extension, so you don't know what to listen for before you start.
 * [rob] What are the other questions we should focus on today?
 * [tomislav] Do we have someone on Chromium team that can look at the current PR and point out potential blockers or the viability of this approach? Can we get someone to take a look?
 * [devlin] I can try to find the time to take a look. Don't know if anything here is a hard blocker, so this may further delay work.
 * [oliver] Alex Rudenko (automation team / WebDriver) may be a relevant expert.
 * [tomislav] Any way to assess viability without fully implementing?
 * [devlin] At some point, yes.
 * [tomislav] How should we proceed?
 * [devlin] I can try to take a look soon. Would it be helpful to review now? Would be valuable to have input from someone on Chromium before proceeding, otherwise we may only have 2 implementations. I think the main outcome will be determining what can be done in a given amount of time. My biggest reticence was around not doing more, but doing less.
 * [timothy] We've implemented test.runTests in WebKit.
 * [kiara] For testing, may be as simple as adding a `browser==chrome` check.
 * [devlin] We've had discussions before that it's not just modifying browser.runTests, but doing that under a certain set of conditions.
 * **Action Item:** Devlin to review the WPT PR.


#### wpt.fyi and interop

 * [rob] Another point of the agenda was getting tests running on WPT.fyi. Is that an open point of discussion?
 * [kiara] Is that site just the result display for the interop project?
 * [rob] wpt.fyi predates interop.
 * [timothy] No, interop is a subset of the tests on that site.
 * [kiara] Having a list of … This could be expanding the test for the extensions runtime namespace. Could add tests for the permissions API. Maybe (browser) action. Other APIs that would be good to get the ball rolling.
 * [tomislav] Not sure how much of the permissions can be tested without implementing granting permissions. That might be a separate blocker.
   * [timothy] I think we were planning on auto-accepting any dialog that got presented, which would include permissions requests.
   * [kiara] Yeah. Also considering modifying the load command to adjust that behavior in certain cases.
   * [tomislav] Ah, didn't realize. I was just assuming permissions from the manifest would be granted on initial install.
   * [kiara] Correct.
   * [tomislav] Missed the second part about `permissions.request` being auto-granted. We also do that in some of our tests. Not sure if it's better as default or non-default behavior.
   * [timothy] That was the initial plan, then possibly adding a toggle later to test deny requests.
   * [simeon] Would this only apply at the extension level? Would you not be able to mix approving some requests, denying others?
   * [timothy] Worth discussing. Could be designed a number of different ways.
 * [oliver] Are there specific benefits we hope to get out of interop? Or is it just a public signal of intent?
 * [tomislav or timothy] Isn't the intent to publicly signal alignment?
 * [rob] Isn't it premature to schedule being part of interop while we don't have cross-browser WPT? It would be too aspirational.
 * [tomislav] Interop could also be “having cross-browser WPT”.
