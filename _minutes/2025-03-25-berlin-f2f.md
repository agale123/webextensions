# 2025 WECG Berlin F2F, Public Notes, Mar 25

Tuesday, the first day of the four-day face-to-face meeting in Berlin (announcement: [#759](https://github.com/w3c/webextensions/issues/759)). Agenda: https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination


## Agenda

 * [State of Browsers](#state-of-browsers)
   * [Google Chrome extensions](#google-chrome-extensions)
   * [Apple Safari extensions](#apple-safari-extensions)
   * [Mozilla Firefox extensions](#mozilla-firefox-extensions)
   * [Microsoft Edge extensions](#microsoft-edge-extensions)
   * [Q&A: Questions & Answers](#qa-questions--answers)
 * [State of the Extensions](#state-of-the-extensions)
   * [Grammarly](#grammarly)
   * [AdGuard](#adguard)
 * [Proposal PR Resolution](#proposal-pr-resolution)
   * [PR 370: Initial Firefox schemas, 2023Q1](#pr-370-initial-firefox-schemas-2023q1)
   * [PR 569: Proposal: i18n-system-languages](#pr-569-proposal-i18n-system-languages)
   * [PR 586: Proposal: documentId in tabs.query() filter](#pr-586-proposal-documentid-in-tabsquery-filter)
   * [PR 587: Proposal: downloads.getFileHash()](#pr-587-proposal-downloadsgetfilehash)
   * [PR 598: Proposal: manifest key trial\_tokens](#pr-598-proposal-manifest-key-trial_tokens)
   * [PR 641: Proposal: Per-extension language preferences](#pr-641-proposal-per-extension-language-preferences)
   * [PR 676: Proposal: Public Suffix API](#pr-676-proposal-public-suffix-api)
 * [Content Script Params](#content-script-params)
 * [Data Collection Consent](#data-collection-consent)
 * [DNR: What's missing](#dnr-whats-missing)
   * [Issue 468: [DNR] Redirect rule does not allow applying other redirect rules to the resulting request](#issue-468-dnr-redirect-rule-does-not-allow-applying-other-redirect-rules-to-the-resulting-request)
   * [Issue 731: Incorrect application of "domainType: thirdParty" in DNR](#issue-731-incorrect-application-of-domaintype-thirdparty-in-dnr)
 * [DNR: Cosmetic Rules](#dnr-cosmetic-rules)


## Attendees

 * Oliver Dunk (Google Chrome)
 * Devlin Cronin (Google Chrome)
 * Simeon Vincent (Mozilla)
 * Rob Wu (Mozilla)
 * Tomislav Jovanovic (Mozilla)
 * Carlos Jeurissen (Jeurissen Apps)
 * Mukul Purohit (Microsoft Edge)
 * Timothy Hatcher (Apple)
 * Maxim Topciu (AdGuard)
 * David Tota (AdGuard)
 * Oleksii Levzhynskyi (Grammarly)
 * Nastia Mihal (Grammarly)
 * Kiara Rose (Apple)
 * Casey Garland (Capital One)
 * Jordan Spivack (Capital One)
 * Andreas Wagner (Mozilla)
 * Lena Cohen (Privacy Badger)
 * William Durand (Mozilla, Data Collection Consent topic only)
 * David Johnson (Apple, declarative cosmetic rules topic only)
 * Krzysztof Modras (Ghostery)


## Notes


### State of Browsers

Quick updates from each browser vendor on current priorities, recent changes, and future plans for extension APIs.


#### Google Chrome extensions

 * Shared Extensions Platform
   * `browser` namespace
   * `permissions.addSiteAccessRequest()`
   * User Scripts permissions changes
   * `runtime.onExtensionLoaded`
 * Browser Work
   * Runtime host permissions UX
     * Not changing default permissions for extensions. Trying to make it easier for users to control settings after installation. Ties into host access request API.
   * Sign-in and sync improvements
     * Always a lot of work happening in the browser: extensions team tasked with keeping up with these changes & minimizing impact on extensions.
   * Protecting users from Malware
     * Need developer mode enabled to use an unpacked extension. Was previously possible to load an unpacked extension & disable developer mode ‚Äì would keep the extension installed and enabled.
   * Chrome Web Store improvements
     * Various updates
 * Ecosystem Updates
   * MV2 deprecation
   * Policy requirements for extensions
     * Every 3-4 months we work on policy updates. Recently made changes to affiliate ads and default search provider settings. When we make a policy change, we also update the FAQs. Iterating on policies based on observed abuse and developer feedback.
   * Enabling AI development and experimentation (prompt API + other experimental APIs)
     * Prompt API: On device. Working towards moving it out of origin trial. A number of other very experimental APIs as extensions explore the limits of current capabilities.
 * Working Together
   * ‚ÄúMedium effort‚Äù feature prioritization
     * Trying to identify work that makes sense to add to the platform that aren't minor things external contributors might work on.
   * Working with other teams to bring their changes to the WECG
     * You've probably seen different Googlers attend WECG meetings. These tend to come up organically as someone is working on changes.


#### Apple Safari extensions

Newest entrant into Web Extensions.

First shipped Web Extensions in 2020, quickly followed with iOS and iPad OS support in 2021. Shipped web extensions on day 1 for vision pro in 2024.

Safari 18 - 2024: open sourced the WebExtensions implementation. Now entirely in WebKit. Aligns us closely with the open web, allows us to be open with what we're doing, can link to our implementation, helps resolve inconsistencies. Enjoying that this is all open source. A 2 year journey ‚Äì looking forward to expanding on this work.

Done a lot since open sourcing. Added support for WebKit-based browsers, Developer ID-Signed & notarized extensions, Document Identifier APIs, getKeys API (OSS contribution), Match Origin as Fallback, main world content scripts, WPT/WebDriver support, Temporary extension installation, Icon Variants, Carlos implemented support for localization improvements that he proposed.

Developer ID-Signed & Notarized extensions: https://developer.apple.com/documentation/safariservices/distributing-your-safari-web-extension#Distribute-your-Developer-ID-signed-and-notarized-extension-outside-the-Mac-App-Store


#### Mozilla Firefox extensions

In January we shipped a trial AI API for extensions based on Transformers.js, a commonly used JS library. We use the same models and API for our internal Firefox features. Model UI is not finished, which is why it's only exposed in Nightly, and should roll out in stable in ~Q3 this year. Behind an optional-only permissions ‚Äì users have to opt in to this feature after installation.

Selection of changes by release version:

 * 128
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/128#changes_for_add-on_developers
   * Many improvements because 128 is a Firefox Extended Support Release (ESR)
   * declarativeNetRequest
     * Disabling individual static rules (WECG)
     * Rule limits
     * domainType
   * Content scripts
     * MAIN world
     * sandbox
     * matchOriginAsFallback
   * optional_host_permissions
   * Event page lifetimes
     * (missing relnotes) [bug 1869125](https://bugzilla.mozilla.org/show_bug.cgi?id=1869125) addListener at top level registers again
     * (missing relnotes) [bug 1844044](https://bugzilla.mozilla.org/show_bug.cgi?id=1844044) permissions.request() keeps alive
     * (missing relnotes) [bug 1771328](https://bugzilla.mozilla.org/show_bug.cgi?id=1771328) contextMenus persist across sessions
 * 130
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/130#changes_for_add-on_developers
   * getURL() resolve inconsistencies (aligned in WECG)
 * 131
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/131#changes_for_add-on_developers
   * storage.session.getBytesInUse() prepare for quota enforcement
 * 133
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/133#changes_for_add-on_developers
   * DNR: bugfix: dynamic rules did not persist (backported to ESR128+ESR115)
 * 134
   * trialML: https://firefox-source-docs.mozilla.org/toolkit/components/ml/extensions.html
 * 135
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/135#changes_for_add-on_developers
   * commands.update can now assign keyboard shortcuts for commands to the F13 to F19 keys.
 * 136
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/136#changes_for_add-on_developers
   * background.preferred_environment (WECG, thanks Carlos)
   * contextMenus.update/remove now reject with error for non-existent menus (resolved inconsistency with Chrome)
   * userScripts API available on desktop! üéâ (will be on Android in 138)
   * (not in relnotes) webdriver-bidi contribution to load/uninstall extensions (thanks chrmod)
 * 137 (upcoming release)
   * https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/137#changes_for_add-on_developers
   * commands.openShortcutSettings (contribution, WECG)
   * storage.session 10 MB quota enforcement
 * AMO (addons.mozilla.org)
   * Markdown support (HTML support dropped), notably from release notes and description.


#### Microsoft Edge extensions

 * ()
   * runtime.getContexts()
   * runtime Events
   * action.onUserSettingsChanged
   * Commands API support for Cmd+Alt on Apple OS
   * sidePanel lifecycle events
   * Chromium Committer (thanks Chrome)
 * Ecosystem
   * Security
   * Improved submission turnaround time (TAT)
     * (see Q&A below)
   * User experience (UX) in the store
   * Extensions on Android (20+ on Canary)
     * (see Q&A below)


#### Q&A: Questions & Answers

 * On ‚ÄúExtensions on Android‚Äù from Microsoft
   * [rob] Is this a closed ecosystem?
   * [mukul] Yes.
   * [rob] Is it possible for extension developers to sign up?
   * [mukul] Yes, please ping on https://github.com/microsoft/MicrosoftEdge-Extensions with details of current Edge Store Extension Id, until a more streamlined way for signup is defined.
 * On ‚ÄúImproved submission turnaround time (TAT)‚Äù from Microsoft
   * [devlin] What are the targets?
   * [mukul] Target is to match Chrome (based on dev feedback). We were taking ~3 days, we have publicly documented 7 days. We used to be on 4 - 5 days on average, reduced to 3 days. Top used extensions have 1 - 3 days.
   * [mukul] How is Chrome doing?
   * [oliver] The Chrome Web Store review process is documented; most reviews completed within 24 hours, 90% within 3 days; if anything takes more than a week we encourage devs to reach out.
   * [oleksii] Grammarly dev here. Is there anything that devs can do to simplify review?
   * [devlin] On Chrome's side: make code as understandable as possible, follow policy as much as possible (e.g. do not try to get around)
   * [oliver] Generally another thing, comments can clarify but we still need to review code so this doesn't significantly change review time and isn't something we encourage.
   * [mukul] When test credentials are needed, make sure that they are correct. Make it obvious what the purpose of the extension is. Branding details in the Extension.
   * [andreas] On the Mozilla side, in addition to the above; Generally following the policy is good; we see so many developers who don't read the policy and try to bypass policies. For example removing security-related headers. Missing data consent when extensions transmit data outside of the extensions (data collection consent topic). Another big one is failure to comply with the source code requirement - when source code is attached, the build does not reproduce or build instructions are incorrect (or missing requirement/dependencies).
   * [maxim] Why does Firefox require source code?
   * [tomislav] Manual review requires readable source code.
   * [casey] We release to Firefox once every few months, and we fail reproducibility every time. Advice on private npm packages?
   * [andreas] It comes up occasionally. Easiest is to include the dependency in node_modules.
   * [casey] Can the dependency be minified?
   * [andreas] No, has to be reviewable.
   * [tomislav] And if there are any concerns: source code is only available to reviewers, not all of Mozilla.
 * On ‚ÄúTemporary extension installation‚Äù in Safari
   * [oleksii] Is there documentation on loading extensions as zip files?
   * [kiara] Yes, https://developer.apple.com/documentation/safariservices/running-your-safari-web-extension#Temporarily-install-a-web-extension-folder-in-macOS-Safari
   * [timothy] macOS 15.4 beta has it; new option in developer settings, enables dev to drag and drop the extension.
   * [rob] You recently mentioned this at one of the public WECG meetings.
     * https://github.com/w3c/webextensions/blob/main/_minutes/2025-02-27-wecg.md
     * Search for ‚ÄúAnnouncement: Safari Updates‚Äù
 * (time check - 11:15)


### State of the Extensions

Quick updates and feedback from attending extension developers.


#### Grammarly

 * (11:15) (oleksii speaking)
 * Performance, challenge: distinguish extensions from page content metrics (INP, RAM) and page crash tracking.
 * Extension release and e2e test automation. Goal: fully automated release cycle on CI with gradual rollout and rollback.
 * Side Panel: experimental mode.
 * Speeding up review process
 * New permissions. Goal: roll out new permissions with ‚Äúwarning‚Äù to at least new user with ‚ÄúHybrid permissions‚Äù proposal.
 * Beta/alpha channels: Set up beta channel for risky, permission update related or architectural changes (MV2->MV3 for example).
 * Q&A:
   * On ‚ÄúBeta/alpha‚Äù channels
     * [andreas] Hypothetically, are you specifically looking for Alpha/Beta, or just a staged roll out? Or are you specifically looking for a dedicated user base on a separate channel
     * [oleksii] Both. Gradual roll out would be super helpful. We already use it in Chrome, and it would be very beneficial in other browsers. When I talk about Alpha/Beta channel, the question is about gradually rolling out user features.
     * [oliver] What are you looking for in the alpha/beta channels? E.g. preserving extension ID, user base, etc.
     * [oleksii] Keeping the same ID would be great. Clarity to user that things may or may not work because they are on a beta channel.
     * [oliver] Review expectations? Quickly roll out beta?
     * [oleksii] Want to push out beta quickly. From beta to stable, should be reviewed.
     * [oliver] A possible approach is to review Beta, and then push that reviewed version out to release without new review.
     * [carlos] Another motivation for multi-channel is backwards compatibility.


#### AdGuard

 * (11:25) (maxim speaking)
 * Bad experience with MV3 migration; had to start background script with our own engine to overcome limitations.
 * Chrome web store rejections due to remote code policy violations. We had to disable custom rules and filters to comply. Hope that this is temporary and that we can restore the functionality later. This limitation makes the life of filter devs more difficult.
 * We have improved the UI of our extension, improved mobile support.
 * DNR rule-only changes; after publishing, the extension is considered corrupted.
   * [oliver] Now that we are here in person, we should sync up on that. We were not able to reproduce
 * Review process difficulty, e.g. in Firefox. It seems that in the past some updates were approved automatically, and it looks like that is not the case any more.
 * Gradual rollout feature in Chrome Web Store is nice, would like to see it in other stores too.
 * Rollback functionality in Chrome Web Store, would also be nice to have in other stores.
 * Plan for future: working on faster initialization of our engine.
 * Q&A:
   * [mukul] What does rollback look like?
   * [maxim] Same extension, just the version number increased.
   * [andreas] Question to Chrome: Ever come across developer complaints where e.g. the version in the extension's own code is inconsistent with the version from the manifest?
   * [oliver] Not seen that.
   * [oliver] Potential issue with rollbacks is if extensions have a db migration that does not account for schema.
   * [oleksii] In code we treat it as a previous version, but the store treats it as a new version. The option is used as disaster recovery.

 * [simeon] (11:35) Dropped WG discussion from today's agenda because of time constraints (rescheduled to tomorrow). 10 minute break.


### Proposal PR Resolution

Working session to review and resolve open proposal PRs. We'll aim for clear resolutions or follow-up paths for each.


#### [PR 370](https://github.com/w3c/webextensions/pull/370): Initial Firefox schemas, 2023Q1

 * [tomislav] Oops
 * [rob] Let's update schemas before merging.
 * [timothy] On that note, we should also update our IDL files, as we updated our API support.
 * **Action Item:** Tomislav to update PR 370.


#### [PR 569](https://github.com/w3c/webextensions/pull/569): Proposal: i18n-system-languages

 * [carlos] Waiting for Rob's review on Firefox patch.
 * [rob] I have posted feedback in the PR. Once the spec discussion finishes I'll get to the Firefox patch.
 * **Action Item:** Rob to review PR 569.


#### [PR 586](https://github.com/w3c/webextensions/pull/586): Proposal: documentId in tabs.query() filter

 * [simeon] I am the only assigned reviewer on this PR. I should add others.
 * [timothy] When implementing documentId in Safari I found it strange that it was missing; I did not know that there was a proposal.
 * [rob] I am in favor of the proposed feature; the proposal process states that proposals should not be aspirational but have a sponsoring browser that commits to its implementation.
 * [simeon] Timothy, would you like to take over as the sponsoring browser?
 * [timothy] Ok.
 * **Action Item**: Apple, Google, Mozilla to review PR 586.
 * **Action Item:** Assign Safari as sponsoring browser on PR 586.


#### [PR 587](https://github.com/w3c/webextensions/pull/587): Proposal: downloads.getFileHash()

 * [simeon] We have approvals from Apple and Mozilla. Chrome is an outlier here.
 * [oliver] We wanted to go through security and privacy review, but that requires a document on Chromium's end, but that doc was never created.
 * [devlin] Example of concern is abuse of the feature as an oracle in cases where the file has a relatively small number of possible values.
 * [rob] The API requires host permissions, and extensions with host permissions can already fetch the URL and read the whole file content directly.
 * [simeon] sponsoring browser?
 * [rob] I'm fine with leaving this open until the author comes back.
 * [timothy] Safari does not have downloads API, so we would not sponsor it.
 * [simeon] Since there is no sponsoring browser, and our Proposal Process requires a sponsoring browser, closing this PR. We are open to re-opening the PR again if there is implementor interest.
 * [carlos] If there is a community member interested in contributing a patch, could that count as sponsoring?
 * [rob] Yes, if browsers are willing to accept patches. In this case it is not opposition to the feature, just lack of prioritization.
 * **Resolution:** Close PR 587 for lack of sponsoring browser.


#### [PR 598](https://github.com/w3c/webextensions/pull/598): Proposal: manifest key trial_tokens

 * [simeon] Maybe missing Firefox approval.
 * [oliver] This is shipping in Chrome.
 * [rob] Tomislav is assigned as reviewer.
 * [tomislav] I took a look before, it looks good.
 * [rob] Can we merge now?
 * [tomislav] Yes.
 * **Resolution:** Merge PR 598.


#### [PR 641](https://github.com/w3c/webextensions/pull/641): Proposal: Per-extension language preferences

 * [rob] Status was that Oliver said that Chrome did not want to sponsor, and asked Timothy and me whether we are interested in sponsoring, but we never replied.
 * [timothy] We are unlikely to prioritize this.
 * [rob] Same.
 * [timothy] Maybe Carlos?
 * [carlos] [Issue 274](https://github.com/w3c/webextensions/issues/274) seems more straightward to implement.
 * [timothy] I prefer 274 over 641.
 * [carlos] One does not exclude the other, but 274 seems to cover the uses cases.
 * [carlos] Should I create a PR with a proposal?
 * [] Same question, is there any sponsor?
 * [timothy] Only if a contributor contributes.
 * [carlos] I can take a look.
 * **Action Item:** Look into PR 641 or issue 274 as alternative.


#### [PR 676](https://github.com/w3c/webextensions/pull/676): Proposal: Public Suffix API

 * [rob] Lots of Mozilla input to discussions, missing feedback from Google/Apple.
 * [oliver] I monitor this PR from time to time, it looks like there is still ongoing (unresolved) discussion.
 * [timothy] Is Firefox still the sponsoring browser?
 * [rob] Yes. Contributor also submitted a patch, but before signing off I directed to the WECG for API alignment first. And here is where it is stuck now.

12:30 - break - return at 14:00


### Content Script Params

 * (14:00)
 * [rob] Often referred to as ‚ÄúglobalParams‚Äù.
 * [oliver] Chrome implementation of an early idea: https://chromium.googlesource.com/chromium/src/+/7ec4d3b806a46c45d25ae83abc6656814d740cf7
 * [rob] Some developers would like to do it per-website, some developers are ok doing it globally. Main use case is being able to access data synchronously and being able to update it later.
 * [oliver] Worth noting some potential use cases. Privacy extensions might have various features that apply to a specific page. User may want to have arbitrary configuration to block specific APIs on a page. Synchronous blocking is necessary to prevent the page from accessing the APIs and saving references.
 * [rob] As a baseline, makes sense to use match patterns or something to align with content scripts.
 * [oliver] Initial chrome implementation was very simple. Seemed to be a global variable declaration. Is that right? Should we talk about other designs?
 * [devlin] Never shipped. Wasn't fully implemented. In general, being able to configure an object that's exposed synchronously makes sense. More natural for the content scripts than calling a specific API.
 * [oliver] What I remember from the CL is that you could mutate it from the content script. Is that right?
 * [tomislav] Would be much more complicated.
 * [rob] Would make sense to be able to change it, but not to propagate that change back. I'm imagining a map-like API. For example a dictionary where you can access only a specific key and the browser only has to serialize that data.
 * [tomislav] Rather than debate per domain or global, what about registering per script? Site specific scripts could use a site-specific match pattern.
 * [rob] Technically possible, but it is not exposed to individual scripts, it is exposed to the execution environment.
 * [tomislav] Right, that's unfortunate.
 * [devlin] We did have two separate use cases covered ‚Äì something site-specific and something global. Wouldn't want to mix those concepts. Having individual separate keys and lazily loading them wouldn't get us anything.
 * [tomislav] IPC is the expensive part.
 * [rob] If you send them infrequently, you have to propagate to every process. If it's only specific keys, you only have to set one value. If you only had to set global params to a single value, but had other values you wanted to expose, say a data URL, ‚Ä¶ if a developer wants to update values infrequently, it would be nice to be able to separate those.
 * [oliver] Good summary of the high level goals. Is this something we're interested in working on?
 * [rob] Would be happy to see a proposal.
 * [devlin] Seems useful
 * [timothy] Don't see any major blockers.
 * [rob] Should we have a notification mechanism to see when a content script's params are updated?
 * [timothy] Don't think it's strictly necessary. Would be fine implementing it initially without. Cost for adding this later would be trivial to add.
 * [devlin] Would also need to figure out in a proposal how value would be set. If we specced it to do
 * [rob] Was thinking we'd do a structured clone of the provided data in the get method.
 * [devlin] I thought the original proposal was `browser.scripting.globalParams`, no explicit get method.
 * [rob] Understood, but `globalParams` is a single value. Was proposing `get()` to expose more values.
 * [devlin] Right, but you just expose each individual value as a property of `globalParams`.
 * [rob] If you expose it as a property, it looks cheap but may be very expensive.
 * [tomislav] Would also be less magical. What you get now may not match what you get later. Get makes it more clear that you have a read only copy.
 * [oliver] Definitely feels weird to have a property change out from underneath you.
 * [tomislav] A get() method clearly communicates that it's a snapshot.
 * [devlin] Don't mean to block on this. Having a get is just substantially different than the previous proposal.
 * [oliver] If we have a get, how do we handle synchronous changes to this data?
 * [devlin] Wouldn't be synchronous. We're just exposing the latest value received via IPC
 * [rob] API only returns data once all data has been propagated to all content processes.
 * [devlin] If you're communicating with the bg script to get a value, just send the value. You can't know in the renderer if you have the latest value.
 * [rob] Getting back to the use case, need to have a value synchronously. Concrete example, extensions that want to modify web API behavior before script execution: at the start of the content script you need to know if you have a value enabled or disabled. Content script needs to know the latest known value.
 * [devlin] Oliver's question was is there any way from the content script side to know if you have the latest value. You can't.
 * [rob] Technically true, but at the moment a script is injected you have a value and it's possible that the value changes as scripts are being injected.
 * [devlin]
 * [tomislav] Anything we could implement to communicate updates could be solved with messaging. I suggest we start with an MVP
 * [oliver] If we start with the assumption that the value exposed will not change after first injection, changing that in the future would be a breaking change.
 * [jordan] Having a watcher in the content script might be the most useful.
 * [rob] Yes, extension devs can use messaging, but it would be cheaper to solve it as part of this API.
 * [tomislav] Would you be making another storage area that's synchronous? Everything else has a listener for onChange.
 * [rob] Yes, would also suggest we only emit the new value.
 * [oliver] If the question is between a global or an API you can call, sounds like we're leaning toward an API
 * [rob] Yes, that's how I'm leaning.
 * [devlin] There are tradeoffs. Making it API based makes it less web-like. May lead us down the path of reimplementing storage.onChanged.
 * [rob] How would you get changes in a property based approach?
 * [devlin] Content script could set a custom setter
 * [tomislav] Not for unknown fields. Would need a Proxy to intercept the setter.
 * [rob] Unless the extension knows the keys that they are interested in.
 * [tomislav] Does any dom API work like that?
 * [devlin] Feels very arbitrary to have a bundle of properties behind a namespace. I'm always interested in ways that you can avoid tying the API to a specific structure. Feels nicer to me as a developer to say ‚Äúhere's an object, just read from it.‚Äù
 * [timothy] Definitely see the appeal of a direct object access approach. Rob's proposal with get and set is making me feel like it should just be part of storage. At that point why are we reinventing that API.
 * [devlin] ‚Ä¶ Also creates the weird issue where all of the other storage APIs are async, but this one is sync.
 * [rob]
 * [devlin]
 * [rob] Another question I had for later is what do we do for values that you do/don't want to persist. The only thing we'd have to guarantee is that a value is exposed to the content process.
 * [devlin] You're saying we'd have a subset of the stored keys in the storage API that would be available
 * [tomislav] Would this be a new value or the same storage?
 * [rob] Same storage, but cached and exposed synchronously. Making data synchronously available in the background script is also a feature request.
 * [oliver] Like the direction this is heading, but it prevents devs from exposing data for specific pages
 * [rob] That's fine, devs can index on keys
 * [devlin] That's different ‚Äì that doesn't limit where the data is exposed.
 * [oliver] No way to give partial access controls based on the current keys.
 * [rob] True, but also true of the current storage APIs. If we wanted to make it origin specific, we should extend the benefit to the existing APIs as well.
 * [oliver] Starting to get very complicated
 * [devlin] Started small, but seems to be getting unwieldy
 * [rob] Is your concern about leaking data to untrusted processes?
 * [devlin] Leaking, and amount of data being sent. Don't want to send down all of the data for every site. Not saying we can't start with just global data, just flagging that keying doesn't solve this.
 * [rob] How much data do we want to make synchronously available?
 * [devlin] Exactly. Storage API allows you to set sub-keys.
 * [rob] Latest values wins. Can't set sub-keys. Can only set top level properties.
 * [simeon] It's ultimately key-value pairs. You're not operating on objects, you're operating on values.
 * [rob] Are we aligned on an approach?
 * [devlin] We have 3 options with very different approaches.
 * [rob] See the appeal of basing on storage API: persistent vs non-persistent (storage.local vs storage.session) get/clear/remove/set/onChanged for free. Also (Chrome-specific currently) incognito and non-incognito have their own storage areas (when incognito:split is used).
 * [oliver] If we were to do storage, would be interested in a new storage area. Want to get to the point where we're not exposing storage arrays by default in content scripts.
 * [rob] storage.getSync but use storage APIs on the back end?
 * [devlin] Agree that we want to limit access, but Rob raises a good point that getting some things for free is very nice. If we decide that we're going to treat different keys different in the same storage area, that effectively achieves the same thing.
 * [tomislav] That's my worry if we use the same storage area. Extensions generally don't have limits for that kind of thing. Easiest solution for a dev is to just expose everything everywhere. A new storage area helps us avoid that.
 * [devlin] Don't know that that's the likely outcome.
 * [tomislav] If we take an existing storage area,
 * [devlin] So your concern is performance
 * [tomislav] Yes
 * [devlin] Okay, separating security concerns and perf concerns. We have a few options. If we reuse an existing area, we wouldn't say ‚Äúmake all of storage.local sync‚Äù, you'd have ‚Äúmake these keys in storage.local sync‚Äù. I'd put making the entire namespace available
 * [oleksii] I feel like devs will make everything available sync. It will be much simpler to use that way.
 * [tomislav] Agree, would want to make it a new area with a low amount of storage available.
 * [devlin] Browser vendors wouldn't want to make everything available all the time. We'd want a way to make a subset of the data available, documented as such.
 * [oleksii] From the developer perspective, if there's a clean interface and a way to protect it with types, it would be easier to work with. Would prefer that over returning some kind of promise.
 * [devlin] Wouldn't want to return a promise. Sync retrieval wouldn't be done through a synchronous promise.
 * [rob] Compressing the discussion. Desirable features: Persistent vs. non-persistant, content scripts and background should be separate, updating a value in the bg would be async, retrieving a value is sync,
 * [oliver] Would be interested in seeing a brief section on how we can expose data per origin and how different approaches might make this easier.
 * (post-meeting edit: Rob created [PR 793](https://github.com/w3c/webextensions/pull/793) with a proposal of an API; this PR was mentioned briefly in the regular WECG meeting on Thursday, and revisited in the issue triage on Friday)


### Data Collection Consent

 * (14:50)
 * [will] At Mozilla we have review-related challenges around our data collection consent requirement. Our policies require developers to implement UI to explicitly request consent from users to collect data. Reviewers and developers don't always agree on what these terms mean or the implementation requirements. The idea is that we may be able to solve some of these issues directly in the browser itself. That's where the proposal comes in. We remove the need for developers to ship their own UI. We get a more unified experience for users (currently very inconsistent).
   * [Introducing data collection permissions](https://docs.google.com/document/d/1UFVCzAr-MDrBzHNcxdv4vq8MoSIqeTKfrIXyjsLCXdI/edit?tab=t.0)
 * [will] We call this concept "data collection permission"`,` because it is similar to permissions (API permissions, host permissions ‚Ä¶), but different enough that we don't want to confuse the concepts. If the data collection isn't required by the extension, it can be declared as optional and requested later with `permissions.request()`.
 * [carlos] This would not change what APIs return?
 * [rob] Correct
 * [casey] How can I test this?
 * [william] Prototyping in next Nightly, at which point it can be tested by any extension developer.
 *
 * [devlin] Have a number of concerns. This appears to be incorporating a number of policies from a given store into the manifest itself. May be challenging if individual stores have different (possibly conflicting) policies. We have some overlap in that we display disclosures in the store (timothy: as do we) and the set of information collected or displayed may not have a great way of aligning across our use cases. I'm hesitant to have this as part of the top level manifest because we're likely not going to have a lot of overlap. See a lot of value for having something like this in Firefox. Is this something you might be okay having in browser specific settings?
 * [rob] We've considered this. In some earlier iterations we've considered arrays of `data_permissions` and `optional_data_permission`, but changes this to a dictionary to allow more flexibility in the data structure. Open question about what browsers would do when they encounter values they don't recognize.
 * [devlin] A lot of the requirements we have stem from regulation/law. We aren't regulators, don't think this group could effectively define the right set of data
 * [timothy] Similarly we're likely to keep this as app store specific data.
 * [mukul] Data in the manifest has to live there forever.
 * [rob] AMO has a place to put the privacy policy. In practice how many users are actually reading that?
 * [mukul] True for developers as well. Most people just click okay. Still, most requirements are coming from law.
 * [oliver] Could you speak more to the motivation for putting this in the manifest? Seems like it would be easiest to have a UI to set some values. Could be an artifact that's generated and included in the file.
 * [will] We treat XPIs as self-contained binaries. We decided to put it in the manifest as it's a developer authored value. Not all add-ons are listed on AMO. Thought it made the most sense to have the manifest be the source of truth.
 * [oliver] Would object somewhat to the classification of the manifest as the source of truth for this type of data.
 * [tomislav] Do you not support use cases where the extension is installed without an internet connection?
 * [devlin] If you don't have an internet connection, then it can't collect data. Also wouldn't see this information in a privacy policy if you're offline.
 * [andreas] We have the concept of ‚Äúunlisted‚Äù extensions (which is different from CWS's concept). Not all extensions are listed on AMO and we still need to display this information.
 * [andreas] Add-on packages are immutable because they're signed. When an extension changes, it gets difficult to handle that in the store. If you package it in the version, you ensure that it's accurate (assuming the developer didn't lie).
 * [timothy] Worry this is getting out of scope for this group. Distribution and stores are out of scope. Trying to avoid server requests by shoving data in the manifest doesn't seem like the right solution. Don't see benefit from including it in the manifest.
 * [rob] Impression so far sounds like there's no interest in including this data.
 * [devlin] Actively opposed for Chrome.
 * [rob] Sounds like we should move this to a separate file, not in manifest.json.
 * [timothy] Not being in the manifest is better for cross-browser purposes as well.
 * [david] Not sure I follow this example: collecting bookmarks. Is it possible to describe specific usage?
 * [rob] Will, are developer-provided explanation strings included in the proposal?
 * [will] No, but we intend to include this on AMO.
 * [oleksii] How does this work as classifications of data change over time? For example, a new regulation classifies an existing piece of data as PII. In the current experience the screen is essentially a short version of the privacy policy.
 * [will] Same issue exists for existing extensions. The solution is that the extension has to submit a new version.
 * [rob] If the extension implements its own UI, it's more likely to implement its exact requirements for the current legal landscape.
 * [timothy] Would like to see reason strings for permissions to give developers a chance to explain what they're requesting and why.
 * [devlin] We discussed that; conceptually we'd be onboard. Might require significant changes in the manifest. Would Firefox disable the extension when a developer adds a new data collection value?
 * [tomislav] New permissions prevent the new version from being installed. New data collection consent values would also block installation.
 * [devlin] Developers are constantly afraid of introducing a new permissions and getting disabled in Chrome. Today, collecting more data doesn't block installation.
 * [rob] Data collection permissions is a new feature where we can implement changes from the start. Independently of that, permissions also have the same issue and we should ideally improve that. There is a WECG issue tracking this ([issue 711](https://github.com/w3c/webextensions/issues/711)).
 * (15:30)


### DNR: What's missing

 * (15:50)
 * [timothy] We have a lot of issues filed about DNR, labeled [topic:dnr](https://github.com/w3c/webextensions/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22topic%3A%20dnr%22). What are good next steps to focus on?
 * [maxim] We prepared many topics


#### [Issue 468](https://github.com/w3c/webextensions/issues/468): [DNR] Redirect rule does not allow applying other redirect rules to the resulting request

 * [simeon] All I recall about this one is concern about infinite redirects.
 * [devlin] Can be addressed with a reasonable max number of redirects.
 * [devlin] The feature request here is that you should be able to chain redirect rules to remove query parameters. The generic request is that you can chain redirect rules.
 * [maxim] Our use case is we have several rules and we want to apply each of them to the same URL. Currently only one rule is applied, the others are ignored.
 * [rob] In all browser?
 * [maxim] I believe so.
 * [rob] Surprising, expect that additional rules would apply in Firefox. Maybe something actionable for this issue is to create a minimal test case to help browser vendors investigate and understand the problem.
 * [timothy] We have an internal issue filed but not investigated yet.


#### [Issue 731](https://github.com/w3c/webextensions/issues/731): Incorrect application of "domainType: thirdParty" in DNR

 * [maxim] Currently only Chrome is supportive. Firefox and Safari are needs-triage.
 * [rob] Looked into this this morning. Firefox's implementation was modeled on Chrome for compatibility. Some main frame requests are considered 3rd party in Chrome. Intentional?
 * [devlin] No. Right now, firstParty if request matches initiator. But if initiator is missing, then it should be first-party.
 * [rob] If the initiator is an opaque origin, would it be first or third party?
 * [devlin] We probably wouldn't always consider it a first party. If we had to pick one, third party. If the initiator origin is opaque, it potentially makes sense to consider it a first or third party request based on the precursor origin.
 * [rob] Are you in favor of treating this case as first or third party?
 * [devlin] If it matches, it could be treated as first party. Don't feel strongly, though. That doesn't match how the web generally treats it. I can see arguments either way.
 * [rob] Agreed. Mostly want it to be consistent.
 * [timothy] Not sure how WebKit handles this.
 * [rob] Did you have the same concept of first and third party before DNR?
 * [timothy] Yes, we that to our DNR implementation.
 * [rob] Oh, but that is a bit different.
 * [timothy] I don't know the rules offhand. Trying to look through code now. I can find an answer and follow up.
 * [rob] Would this be useful to have a test for in WPT?
 * [kiara] Confirmed that Safari behaves as expected.
 * [timothy] Looks like WebKit checks if the top level domain matches the request, that's it. If they match, it is `firstParty` otherwise it is `thirdParty`. All main frame navigation are `firstParty`.
 * [alexi] Wanted to raise `mailto:` links. Short version: users set up gmail to be their mailto handler. When a new tab is opened, PrivacyBadger accidentally modifies some links.
   * [alexei] https://github.com/EFForg/privacybadger/issues/3066
   * [rob] This issue was also raised in a recent meeting (minutes: [2025-03-13-wecg.md](https://github.com/w3c/webextensions/blob/main/_minutes/2025-03-13-wecg.md)).
   * [alexi] Seems to be past the protocol handler. A tab is opened and we can't associate it with the link.
   * [rob] Need to investigate this more. DNR doesn't currently support matching missing or opaque initiators.
   * [devlin] Would be curious to know where these requests are coming from. Alexi, you mentioned that this may be coming from a service worker?
   * [alexi] Correct.
   * [rob] I'll investigate this more.
   * [devlin] For XHRs being initiated by clicking mailto links, those are being labeled as 3rd party, but should be considered first party (if they're coming from the gmail SW as posited by Alexei).
   * [rob] Is this Chrome-specific?
   * [alexi] Don't know. Have only received bug reports for Chrome.
   * [timothy] Safari does not redirect `mailto:`
   * [rob] If you can try this out in Firefox and verify it's a cross-browser issue. If not, follow up in a Chrome bug.
 * **Resolution:** top-level navigation without initiator should be classified as domainType: firstParty
 * **Action Item:** Firefox to implement resolution of issue 731.
 * **Action Item:** Chrome to implement resolution of issue 731.


### DNR: Cosmetic Rules

 * (16:16)
 * Related issue:
   * [Issue 362](https://github.com/w3c/webextensions/issues/362): Proposal: Declarative Cosmetic Rules
 * [timothy] We discussed this for a while, also in San Diego. Action item was for Apple to come up with a proposal. David created a proposal for what we think may make sense.
 * [david] (screen-shares early draft of proposal; the proposal will shared at a future WECG meeting)
 * [rob] Is the "selector" condition the only proposed condition, or one of multiple?
 * [david] This is the only currently proposed condition. I think we can do others like URL matching in the future.
 * [devlin] Do we assume that most DNR conditions will be applicable, or will we only support DNR conditions we see strong use cases for?
 * [david] We can have namespace discussions and may want to use this as an opportunity to rename DNR.
 * [devlin] We can have the namespace discussion separately. Something like `initiator` may not make sense for a CSS rule _[so we should discuss if we support all conditions]_.
 * [rob] We could do this based on if the condition matches the main frame request.
 * [devlin] Would be confusing for developers, and hard to implement as a lot of required information is not kept. Also, what happens if it used to match but no longer does because DNR stripped headers?
 * [devlin] Do we need network request data, or say rules only ever require things we can determine from the document?
 * [devlin] Would also be good to discuss other actions.
 * [timothy] Adding styles would always need host permissions.
 * [devlin] Would be good to find other actions that don't need adding styles.
 * [tomislav] For example, `visibility: none`.
 * [devlin] Maybe there are other cases where we can safely allow setting specific properties. For others, we require a host permission.
 * [rob] Sounds like we need to include requiring and not requiring host permissions in the design. E.g. `{ action: ‚Äúcss-display-none‚Äù, fallbackActionCSS: ‚Äúdisplay:none‚Äù}`. Browsers not supporting ‚Äúcss-display-none‚Äù would apply the fallbackAction (and require host permissions). Browsers supporting css-display-none would hide the matching elements, without requiring host permissions.
 * [devlin] Can see that working.
 * [casey] Can you see a world where we avoid host permissions?
 * [devlin] Yes. We want this API to also include additive parts. Adding things without requiring host permissions gets tricky fast. Things like the tabs permission, where we selectively leak URLs‚Ä¶
 * [timothy] Doesn't work for Safari (because the ‚Äútabs‚Äù permission does not reveal the URL of a tab, only host permissions does).
 * [oliver] Might be out of scope for this, but declarative badging
 * [devlin] Would require host permission.
 * [oliver] What about badging images with a static image?
 * [devlin] Early feedback is that extensions want to be able to do more than show a static image.
 * [oliver] 1Password does this. It just injects a static image on input fields.
 * [devlin] Other folks wanted richer interactions. Ability to react to hover, display custom content, etc. You can address that with an iframe, but you also know when you're being included. Going back, we can start with it being subtractive and in the future consider additional capabilities.
 * [rob] The idea mentioned before of having a `fallbackActionCSS` gives extension devs a way to safely fall back to an expected behavior, even if a browser does not recognize/support a feature. Compare with plugins, legacy `<object>`/`<embed>` elements that fall back to showing fallback content if the plugin is not available (and show the plugin's result if it is).
 * [casey]
 * [david] Extensions can block requests, but doing so leaves holes in the document. We want to give them a way to clean up those issues.
 * [devlin] Would likely want to also put some limitation on the complexity of the selector. We've seen that watching complex selectors for changes can be quite costly.
 * [timothy] Don't have a similar concern. Recently opened up content filtering to allow the `:has()` selector once we made it performant. Defining a common set of performant selectors sounds difficult.
 * [rob] Alternative for extensions is to use content scripts, which would be considerably more expensive.
 * [devlin] Right, depending on how they do it. ‚ÄúSelector‚Äù is overloaded, but I assume this includes ancestors and children. But don't think you should be able to chain a 50 has selectors.
 * [rob] Going back to the proposal, is there more we wanted to cover?
 * [david] I would like to figure out the MVP for this, use cases etc. Don't want to let perfect be the enemy of good.
 * [devlin] Concrete use cases include dark mode and high contrast extension. I like the idea of having a way for a high contrast extension to change colors without needing &lt;all_urls>
 * []
 * [timothy] Safari can support any DNR match cases for this.
 * [rob] Also curious how many match cases you'd need to cover.
 * [maxim] 24,000 rules in AdGuard Base filter are hiding rules.
 * [devlin] All of those would need to be available in the renderer.
 * [timothy] We support this, and I know a lot of content blockers do today as well.
 * [oliver] It's not like you need to look for those on every page, right?
 * [maxim] Right.
 * [devlin] Depends on when you need them. Content scripts currently do this at document_start.
 * [oliver] I assume that when you call insertCSS you're also solving this.
 * [devlin] That's shared with all processes.
 * [rob] David, do we need to return to this topic?
 * [david] I have enough to think about for now, but if time allows and folks have more feedback, happy to revisit.
 * [oliver] Different browsers have different limits. Would be nice to try to align on a common set of limits across browsers.
 * [david] (AdGuard) Easylist has 14,000 generic CSS rules that apply to every website.
 * [tomislav] Is that injected on every page?
 * [maxim] It depends. Some are complex, some are simple. Also wanted to ask if this proposal would cover scriptlets or if that's out of scope.
 * [tomislav] Starting with CSS because that seems more manageable. I expect we'll learn a lot in that process and may
 * (16:45) closing
