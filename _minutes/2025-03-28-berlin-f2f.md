# 2025 WECG Berlin F2F, Public Notes, Mar 28

Friday, the fourth day of the four-day face-to-face meeting in Berlin (announcement: [#759](https://github.com/w3c/webextensions/issues/759)). Agenda: https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination


## Agenda

 * [Issue triage (Part 2)](#issue-triage-part-2)
   * [Issue 713: Should tabs.Tab.lastAccessed be optional?](#issue-713-should-tabstablastaccessed-be-optional)
   * [Issue 717: Feature Request: [ContextMenus] Include &lt;canvas>s in the "page" ContextType (or it's own ContextType)](#issue-717-feature-request-contextmenus-include-canvass-in-the-page-contexttype-or-its-own-contexttype)
   * [Issue 783: Conditional enabling/disabling of DNR rules.](#issue-783-conditional-enablingdisabling-of-dnr-rules)
   * [Issue 694: Unlike webRequestBlocking, DNR rules are not applied to redirected requests — should this behavior be reconsidered?](#issue-694-unlike-webrequestblocking-dnr-rules-are-not-applied-to-redirected-requests--should-this-behavior-be-reconsidered)
   * [Issue 198 Action.default\_area](#issue-198-actiondefault_area)
   * [Issue 12: request: allow to retrieve a frameID from an &lt;iframe> element](#issue-12-request-allow-to-retrieve-a-frameid-from-an-iframe-element)
   * [Issue 617: manifest key to enable automatic injection of content scripts after installation/update](#issue-617-manifest-key-to-enable-automatic-injection-of-content-scripts-after-installationupdate)
   * [PR 793: Add proposal: Synchronous data at startup](#pr-793-add-proposal-synchronous-data-at-startup)
   * [Issue 719: Adding a temporary listener just for the current run of the service worker or event page so it doesn't wake up next time for this event](#issue-719-adding-a-temporary-listener-just-for-the-current-run-of-the-service-worker-or-event-page-so-it-doesnt-wake-up-next-time-for-this-event)
   * [Issue 783: Conditional skipping of DNR rules.](#issue-783-conditional-skipping-of-dnr-rules)
   * [Issue 77: Proposal: Provide a secure drop-in replacement for window.postMessage()](#issue-77-proposal-provide-a-secure-drop-in-replacement-for-windowpostmessage)
 * [Open discussion](#open-discussion)
 * [Long Term Direction](#long-term-direction)
   * [Events and live objects](#events-and-live-objects)
   * [Named globals](#named-globals)
   * [browser.addEventListener](#browseraddeventlistener)
   * [API design principles](#api-design-principles)
 * [Wrap-up discussions](#wrap-up-discussions)
   * [Next meetup and goals](#next-meetup-and-goals)


## Attendees

 * Oliver Dunk (Google Chrome)
 * Devlin Cronin (Google Chrome)
 * Simeon Vincent (Mozilla)
 * Rob Wu (Mozilla)
 * Tomislav Jovanovic (Mozilla)
 * Carlos Jeurissen (Jeurissen Apps)
 * Mukul Purohit (Microsoft Edge)
 * Maxim Topciu (AdGuard)
 * David Tota (AdGuard)
 * Kiara Rose (Apple)
 * Casey Garland (Capital One)
 * Jordan Spivack (Capital One)
 * Krzysztof Modras (Ghostery)
 * Jan Biniok (Tampermonkey)
 * Timothy Hatcher (Apple) – afternoon


## Notes


### Issue triage (Part 2)


#### [Issue 713](https://github.com/w3c/webextensions/issues/713): Should tabs.Tab.lastAccessed be optional?

 * [oliver] We implemented in Chrome; in MDN marked as optional; In Firefox set to tab creation, but there is a code comment stating that it may be set at startup in some cases. On MDN set to optional. Chrome always set to when tab is created.
 * [oliver] I think that it should be when the tab is created, and not optional.
 * [devlin] Most compelling reason to show nothing is that browser start is inaccurate. Current handling in Chrome is that lastAccessed is set to tab creation time.
 * [krzysztof] Would the value be synced?
 * [simeon] Would be nice, but don't expect it to be.
 * [devlin] It won't be. Don't think we should conflate creation time with last accessed.
 * [rob] Use cases?
 * [simeon] My use case is to review my oldest tabs
 * [rob] Based on the name I would expect it to match whenever the user has touched (activated) the tab for the last time, potentially from a previous browser session.
 * [devlin] Looking at code, in Chrome we persist the lastAccessed value across sessions.
 * [oliver] Sounds like we're aligned that matching expectations and having this be optional, and unset until the tab is first accessed, is the direction we want to head. This is as long as it is a safe enough change given current usage.
 * [rob] I'd have to scan extensions for current API usage to determine whether it is a safe change to make, but from the API perspective it sounds sensible.
 * **Action Item:** Rob to scan for usage of lastAccessed (issue 713)


#### [Issue 717](https://github.com/w3c/webextensions/issues/717): Feature Request: [ContextMenus] Include &lt;canvas>s in the "page" ContextType (or it's own ContextType)

 * [rob] Is Chrome supportive to adding a “canvas” context type?
 * [devlin] See the utility of not having to use “all”. Hesitant about “canvas”. Could this be covered by image? Do we put image context menus on SVGs?
 * [rob] Not sure.
 * [devlin] Gut feeling is that we should do “image”
 * [krzysztof] What about cases where the page is drawn on one large canvas, e.g. Figma?
 * [simeon] Extensions cannot meaningfully distinguish contents of a canvas – you'd have to parse the image data or get access to underlying (JS) renderer.
 * [rob] If extensions want to do something with canvas, they'd also need host permissions. Knowing that there's a canvas element doesn't necessarily help the extension provide functionality.
 * [simeon] If you invoke a context menu on an image, is the image data transferred to the background?
 * [devlin] Image data is not, but the source URL is.
 * [rob] Is the use case broad enough that we should add support for this?
 * [devlin] Don't think we should have a canvas type. We currently have conceptual types. Arguably we could put it under “page” as a safe fallback if “image” isn't a good fit. It's ultimately strange that you currently have to use “all”.
 * [simeon] Agreed.
 * [rob] Can you review Chromium source to see what would make the most sense?
 * [devlin] Can do that async.
 * [rob] What are your thoughts on CSS selector?
 * [devlin] Can see utility, but that introduces new privacy and security considerations.
 * [rob] Wouldn't have to watch. It's directly driven by user selection.
 * [devlin] Right, but then you have selector counts, etc. Don't want to pursue that solution for this request.
 * [rob] So not supportive, but could be convinced?
 * [devlin] Neutral to negative.
 * **Action Item:** Devlin to check why “all” has to be used instead of “page” for canvas in Chrome.


#### [Issue 783](https://github.com/w3c/webextensions/issues/783): Conditional enabling/disabling of DNR rules.

 * [maxim] We have generic rules; we'd like to disable some dynamic rules based on some conditions.
 * [rob] Dynamic or static rule?
 * [maxim] Currently dynamic, but could be useful for both. Can't fit all conditions in a single generic rule.
 * [rob] Trying to understand usage potential. Say you have 1000 exceptions, that may work, 10000 may be a stretch. E.g. if extensions use 10000 very broad conditions, each with their own “except this condition”, that is harder to optimize.
 * [krzysztof] We have a use case for this.
 * [maxim] I've only calculated refer rules, ~590. When users report issues with stealth feature is breaking their site, filter developers use this to disable the feature on a specific site.
 * [krzysztof] At Ghostery we also have a need, and try to use “allow”, it cannot always be used. We'd like to toggle a fragment of a ruleset (more than one, possibly 1000).
 * [devlin] Overall seems fairly reasonable. Valid use case, can't be trivially done with the current API. Introducing a new action type here doesn't seem terribly complex or like API bloat. Not opposed.
 * [rob] Let's table and revisit later today if there's time.
   * ([this issue was revisited later today](#issue-783-conditional-skipping-of-dnr-rules))


#### [Issue 694](https://github.com/w3c/webextensions/issues/694): Unlike webRequestBlocking, DNR rules are not applied to redirected requests — should this behavior be reconsidered?

 * [jan] Title may be a bit misleading; TamperMonkey doesn't have complete control over the network request. Now use DNR to modify headers, but this does not work after redirects. I expect headers to be added post redirects since this is also specified in https://www.rfc-editor.org/rfc/rfc9110.html#name-redirection-3xx. Only automatically added headers are supposed to be removed, and I don't think that DNR-added rules should count here.
 * [rob] I can see that viewpoint, I don't think that it should always be viewed as automatic.
 * [jan] If a user script executes a long pull, that effectively block the extension for 30 seconds.
 * [rob] Assumption is that the extension doesn't have enough granularity to match the specific request, so it has to match all requests. That isn't necessarily true. Create a new tab in the background, use that new context to execute the request. Not the only way to do it, but demonstrates that there are alternate solutions. Probably better to have an iframe.
 * [jan] Doesn't the specification apply to DNR rules?
 * [rob] DNR is a generic API; dangerous to automatically add it to all requests across redirects.
 * []
 * [rob] Potential way to address this is to add a rule to make header modification sticky.
 * [jan] Works around the fact that the browser doesn't follow the spec.
 * [rob] It's subjective whether this is “automatic”. You aren't creating the request – maybe you are – but it could be coming from the page.
 * [krzysztof] What about adding a custom header? I've seen this done elsewhere. Can be a footgun
 * [rob] for clarity, I'm in favor of the use case, but trying to find an API that's a good fit for this and is harder to accidentally misuse. There's an existing issue tracking \_ headers. If that were added, would you still want this functionality in dnr?
 * [jan] Still think the current behavior is buggy, but that could be used.
 * [devlin] It's an inconsistency between browsers. That should be addressed. I think it makes sense to preserve headers that would normally be preserved across redirects.
 * [rob] They are if the web page sets them.
 * [devlin] I think it makes sense to preserve them if they're set by a DNR header.
 * [rob] If it set a cookie header, would you keep that?
 * [devlin] If it would be preserved in a normal redirect scenario, yes, if not, no.
 * [jan] Treat them like other headers.
 * [rob] Are we aligning on if possible, try to follow the spec if it makes sense?
 * [devlin] Yes. If there's a behavior change, we should do outreach. At a high level, aligning on web behavior makes sense.
 * [rob] Still concerned that modifying a header for example.com, whether that carries over.
 * [devlin] Only if it would normally apply to example.com. Basically the request would follow the normal flow of redirects. In cases where it would be stripped, it's stripped. If it would persist, it persists. What are the action items?
 * [rob] We don't do anything special currently. Would like to avoid creating custom behavior in extensions for this.
 * [devlin] I should behave the same way it would normally request. The extension said “I want to apply this header”, it should apply.
 * [rob] I'm comfortable doing this on the extension origin. I'm not comfortable with the general web.
 * [devlin] Extension specific header handling seems weird.
 * [rob] Seems like it's more about the intention of the extension developer.
 * [jan] Behavior already exists for normal web requests against a web server. … Just a question of when the rule are applied in the request chain.
 * [rob] Only fetch can set headers. If this applied to main frame requests, would you be okay with handling that differently?
 * [devlin] Would want to see what the impact was. If we do outreach and see if developers are supportive.
 * [rob] Neutral.
 * [devlin] Do you agree this is something we should fix because it's an inconsistency.
 * [rob] Agree fixing inconsistencies is good. Don't want to do things differently
 * [devlin] As Jan said, it probably depends on what step in the request chain you're applying the rule. Seems we all agree something should change. Devs in the room who use this API all the time seem to think it's useful. Think we should follow up with developer outreach.
 * [rob] I understand that this issue is driven by a desire for functionality that cannot be achieved in other ways right now. Concerned that the focus on this specific implementation approach can result in negative consequences. Supportive of the capability, not immediately convinced that the requested alignment is the best way to do this.
 * [simeon] Break time. Devlin, please add a comment to the issue to capture the current status.


#### [Issue 198](https://github.com/w3c/webextensions/issues/198) Action.default_area

 * [carlos] Briefly discussed this yesterday; Chrome expressed a personal position with the caveat that this is ultimately decided by Chrome UX. Wondering about other browsers.
 * [carlos] Is Edge favorable towards the ability for extensions to specify that the extension button should be pinned?
 * [mukul] We generally try to follow Chromium's implementation.
 * [krzysztof] This is a UI/UX question, and the question is whether individual browsers can ask their UX teams to allow to be pinned.
 * [simeon] They can ask, but it's out of scope for this group to decide.
 * [carlos] Would Edge be able to customize the logic in their fork of Chromium?
 * [mukul] Would like to add it to Chromium code if we did.
 * [devlin] If it wouldn't be exposed by default in Chrome, it wouldn't be in Chromium.
 * [mukul] We could consider that, but it would be in Edge, not Chromium.
 * [carlos] Why wouldn't Chromium allow something not used in Chrome?
 * [devlin] We don't want code that we don't use.
 * [rob] Non issue in Firefox, right? We support default_area.
 * [carlos] I'll test to double check.
 * [kiara] We pin icons by default. Only way for it to not be pinned is if the user customizes the toolbar to remove the extension.


#### [Issue 12](https://github.com/w3c/webextensions/issues/12): request: allow to retrieve a frameID from an &lt;iframe> element

 * [oliver] I've periodically checked on this in the past. The conversation that it always comes back to is the desire to not expose frameID in the renderer process. Would be more willing if the information is less useful (powerful/dangerous).
 * [rob] How about documentId?
 * [devlin] Haven't had that discussion. In theory it's opaque, so there shouldn't be a concern. Not currently exposed in the renderer.
 * [rob] Is it a must-have to keep it out of the renderer, or are you open to keep it out?
 * [devlin] Don't expect so.
 * [rob] Feedback from Giorgio based on yesterday's storage discussion is that its utility is limited without documentId. Would you be open to something like getDocumentId for the current frame?
 * [devlin] I think so, yes.
 * **Resolution:** Chrome, Firefox, Safari in favor of runtime.getDocumentId()


#### [Issue 617](https://github.com/w3c/webextensions/issues/617): manifest key to enable automatic injection of content scripts after installation/update

 * [carlos] In Safari and Firefox, content scripts are injected on installation; in Chrome they are not. Proposal to allow extension to specify whether to inject on install/update. In my extensions I inject on installation and have to do so manually by parsing content_scripts.
 * [simeon] This is a common, but not frequent request. I'd ballpark that I see this every ~6 months.
 * [devlin] Do you (Firefox) ignore run_at…?
 * [rob] run_at is the earliest point of injection, not the latest.
 * [devlin] Concern is that ignoring run_at causes problems for scripts injected late.
 * [rob] If there was an option to control this, developers would have to consciously opt in.
 * [devlin] No concerns from a performance point of view. Some concerns around prioritization and cost. Seems non-trivial for us to implement. Understand that it's a pain to work around, but it's nonetheless possible. Ideal solutions are not uniform. Some extensions will want to inject late, some will want to reload the page, maybe others. Not saying it's infeasible to implement, just not sure it's the right issue to prioritize. Suspect that this will not eliminate special handling. Still need to add custom logic to handle cases where you're injected late.
 * [jan] Expect that document_start is the document's start.
 * [simeon] But it's not always, as just discussed.
 * [krzysztof] Surprised – wonder how other extensions handle this. If you have to shim APIs, the only thing you can do is run before the page.
 * [rob] Haven't had issues filed against this.
 * [krzysztof] They get filed against the extensions.
 * [rob] Devlin - are patches welcome or are you opposed?
 * [devlin] Currently mildly opposed. Violates guarantees provided by the API, confuses the injection model.
 * [krzysztof] Would you be open to a cross-browser approach to this request?
 * [devlin] Not against it, but would rather explore other solutions.
 * [krzysztof] Alternative is to have 2 APIs to handle document_start injection.
 * [rob] How would that solve?
 * [krzysztof] Gives a way to recover.
 * [rob] Content script can set a flag at injection time.
 * [devlin] Happy to continue discussing in the future.
 * [rob] are you open to having some way to signal intent?
 * [devlin] Open to discussing, e.g. a way to signal that a script can run soon.
 * [rob] And if that is used, would you run after installation.
 * [jan] document_idle scripts are already prepared to run late
 * [devlin] Yes, in those cases they can be dynamically injected in response to a browser action click.
 * [rob] Scripting APIs have injectImmediately. Would you be open to that in content script declarations?
 * [devlin] Too much bikeshedding. Don't want both injectImmediately and run_at. Combining those concepts is contradictory. Would want a flag that indicates its okay to do this.


#### [PR 793](https://github.com/w3c/webextensions/pull/793): Add proposal: Synchronous data at startup

 * [rob] Devlin, thoughts?
 * [devlin] Don't like the names.
 * [rob] Names may change, we can bikeshed on that later.
 * [devlin] We'd like to do something in Shared memory for performance reasons, not excited about that. In theory it helps with some cases desired by user/content scripts, but the lack of separation by site is going to be a major limitation.
 * [rob] Open to `matches` or something. Extensions may have their own idea for what should match (e.g. etld+1), so this may not always work.
 * [devlin] Don't know how we'd handle that from an implementation point of view.
 * [rob] Could offer extension authors a map primitive to store the data, and extensions can use keys composed of the key name plus site/document origin/etc.
 * [devlin] 2 limitations. Size limit become much more challenging for devs. Currently proposal doesn't have site specific data. Not having that concept, expect that devs will hit this limit much more often. Without it, there's no a security guarantee for limiting data exposed to a renderer.
 * [rob] Because the data has to be synchronously available, there should be a global limit.
 * [oliver] Hesitant about the fact that we have many use cases that are site specific and this proposal requires workarounds to address that.
 * [tomislav] Also tab specific, but that's out of scope of what we've covered so far.
 * [rob] Could we mark those issues as future work?
 * [devlin] Don't know that this is the right API to solve that problem. It can help with it and solve other problems, but don't know that this solution would apply to site specific etc. data in the future.
 * [rob] I'm okay with not covering those case in the future with this API.
 *
 * [rob] Different case, … any concern about the chattiness of this? Current onChanged is very chatty.
 * [devlin] Not as much of a concern in the larger scheme of things. Storage API has never been performant. We guide devs away from it for perf sensitive cases.
 * [rob] For this proposal, since it's a new API I'd want to remove the perf issues in the implementation. If the devs really need the data, they can already fetch the value for a key. If they want the old data they could fetch it from the script.
 * [devlin] Don't like having those kinds of inconsistencies across storage areas. The closer it can emulate the existing areas the better. Don't think onChanged would be a major perf hit.
 * [rob] Perf may be fine, but it's currently not possible to listen for specific keys. A listener would have to subscribe to all events.
 * [devlin] Storage API is bad. We can improve it. What's the goal here?
 * [rob] Besides reading synchronously, extension authors may be interested in subscribing to changes. I tried designing the API with minimal requirements. Including oldValue / newValue in the onChanged event would require the values to be read from shared memory, even if the specific content script does not care about it.
 * [devlin] Agree that's an issue, but would prefer to align as closely as possible to the existing surface.
 * [rob] That means we'd have to dispatch old and new value.
 * [devlin] Seems orthogonal. Don't think we should have big differences if we call this a StorageArea. But those are issues we could address in the future.
 * [rob] I'll update the proposal to mention that oldValue and newValue are included as usual. This may have more overhead at runtime, but is at least consistent with other StorageArea.
 * [rob] What are quota sizes that would be acceptable in Chrome.
 * [devlin] Between 1 and 10 MB. Assuming its in shared memory, its not that costly.
 * [rob] Assumed a lower starting value (100kb) in the proposal, willing to consider 1 - 10 MB if you're fine with it too.
 * [devlin] This isn't just content scripts, also in background. Same limits in content and background?
 * [tomislav] If the areas are different, then they can be different.
 * [rob] We can resolve the remaining issues async.
 * **Action Item:** Rob to update PR 793 based on feedback, to more closely match StorageArea semantics.


#### [Issue 719](https://github.com/w3c/webextensions/issues/719): Adding a temporary listener just for the current run of the service worker or event page so it doesn't wake up next time for this event

 * [simeon] Short version; toph is looking for a way to register a listener that does not trigger startup of a background service worker.
 * [rob] (…) Right now it is impossible for a browser to tell what an extension wanted. If extensions want to control what wakes them, we could have a manifest key that takes events that would to prewarm the background, and stop trying to auto-detect.
 * [timothy] Interesting, I'd be interested in an idea like that.
 * [krzysztof] We did something like this in Safari. We had synchronously registered event listeners in the background to ensure that we'd start up. This hack is no longer necessary.
 * [maxim] Wouldn't it be better to have an option on the listener?
 * [rob] That's an option. By putting it somewhere statically, you give a strong signal that doesn't have to worry about timing.
 * [krzysztof] … Based on feature flags we could make a choice on whether or not to enable the listener.
 * [oliver] You mean declarative, not just in the manifest, but having both a manifest entry and an API for it.
 * [devlin] Generally supportive of doing things to help the browser guess less.
 * [rob] There was a proposal before about changing addListener completely.
 * [devlin] I think the manifest key is the direction we were leaning before. Being able to know beforehand from the extension is very useful. In the past there have also been discussions about having a queue of events that could be drained after you asynchronously register a listener.
 * [krzysztof] May be too late to process those events.
 * [devlin] Right, if you need a synchronous listener.
 * [krzysztof] Devs can also manually create their own queues
 * [rob] Manifest entry would help, but having a way to register a non-waking listener would still be useful. Are there any APIs that take a non-object as a listener's second parameter?
 * [devlin] Not that I know of. You could potentially change filters to configuration options.
 * [oliver] Just looked through Chrome APIs and couldn't find anything where we take anything but an object as the second argument of a listener.
 * [krzysztof] MV3 design and docs state that only listeners assigned synchronously on first parse in order to receive the listener.
 * [devlin] One of the issues with async registration is that if it's async but fast, it will still work. Not saying that's a good thing, but it will work most of the time if you're fast enough.
 * [timothy] Safari is permissive here. We wait half a second or so after the page load event (or SW equivalent) for async registrations.
 * [krzysztof] Would argue that's harmful as it gives a false impression of reliability.
 * [oliver] Would be hard to define the right conditions. Maybe we could show a warning saying that we've detected an unreliable pattern.
 * [rob] To conclude this issue, sounds like we're aligned on using the second parameter as an object with a property to specify whether or not to persist across restarts.
 * [timothy] I'd be supportive of that.
 * [rob] And from the discussion before, both Firefox and Chrome are also supportive of this.
   * Updated labels and added comment: https://github.com/w3c/webextensions/issues/719#issuecomment-2761477404
 * **Resolution:** Accept second parameter in addListener to take options to control persistent listeners (issue 719)


#### [Issue 783](https://github.com/w3c/webextensions/issues/783): Conditional skipping of DNR rules.

 * (continuing from the morning where we briefly touched on this issue)
 * [rob] Added feedback to use “skipping” instead of “disable”. Updated the issue title to reflect.
 * [rob] Are we aligned at a high level?
 * [devlin] I think so, yes. I think we're close enough for someone to create a proposal, assuming browser interest in implementation.
 * [timothy] We don't currently support disabling rules.
 * [rob] Not disabling. This is skipping rules during the current evaluation.
 * [timothy] Only issue is we don't currently preserve IDs after translating rules into the internal representation.
 * [rob] How does it work with header rules? Multiple rules can stack.
 * [timothy] We don't need IDs for that. Anyway, I'll add the supportive Safari label.
 * **Resolution:** Chrome, Firefox, Safari in favor of supporting a way to conditionally skip DNR rules.


#### [Issue 77](https://github.com/w3c/webextensions/issues/77): Proposal: Provide a secure drop-in replacement for window.postMessage()

 * Objective: is there support to send an extension message directly to a specific frame element?
 * [carlos] This was proposed by a security researcher to address a security issue where it is difficult to send a message to a specific frame.
 * [devlin] This is saying, from a content script context, to sending a message to a content script in a sub-frame? And it doesn't need to be synchronous?
 * [carlos] Correct.
 * [devlin] If it's async, it's possible today by proxying through the background context.
 * [carlos] Not in all cases. Popups don't have tabs.
 * [rob] And to forward a message, a frameId is needed. Not all browsers support the `runtime.getFrameId()` method.
 * [devlin] If this were going to be asynchronous, just tweaking the APIs to let you proxy through a background context would be ideal.
 * [carlos] How would you link everything?
 * [devlin] Taking the case of a tab, parent frame takes runtime.sendMessage and posts a message to the background, background relays it to a frame.
 * [rob] If extension developers are content with using postMessage without the response behavior, could we have an extension API like `window.postMessage` that offers one-way messaging mechanism with structured cloning support to send a message from content script to a content script in a specific frame?
 * [devlin] A bit worried about practicality. Similar to the storage API, extension messaging isn't great. It's slow, it broadcasts, etc. If we try to solve everything, we're not going to do it.
 * [rob] Could we ask the web platform if they'd be willing to accept a targeting parameter, an extension could then use that to send a targeted message
 * [devlin] We've been working with a Chrome person (Dominic) on WHATWG to explore appetite for integration of extension concepts into web platform APIs. This could be something we could explore after the initial proposals.
 * [devlin] Personally supportive of leveraging web messaging. Not certain whether it is something we could get to in the next 12 months. Opposed to `runtime.sendFrameMessage()` as a method.  If we use extension messaging to solve this (in the nearer term, since leveraging web messaging is further out), would prefer to fix any gaps (e.g. getFrameId()) to enable it in existing methods rather than introducing a new one.


### Open discussion

 * [simeon] Opportunity to ask questions that don't make sense as questions.
 * [krzysztof] documentId should be added to all webRequest implementations.
   * [timothy] Have supported this in Safari Tech Preview for a few releases. Will be in the next release.
   * [krzysztof] Okay, that covers what I was after.
 * [krzysztof] Storing UInt8Array in storage.local. Firefox already support this. Safari supports this too (editorial note: this is wrong, see below). Chrome should ideally support this.
   * [devlin] I'd like to support more values in storage.
   * [timothy] Surprised it works in Safari, but cool. We store them internally as JSON.
   * [rob] Did you get a true Uint8Array back, or a regular array of integers.
   * [krzysztof] Upon double-checking, it is an object with indexed map of bytes, e.g. `{0: 123, 1: 123, 3: 123}`.
   * [timothy] That's something we've wanted to do. Don't know how feasible it is in the short term.
   * [tomislav] Now that we discovered this serialization issue, do you use some form of structured cloning?
   * [timothy] We use JSON. Surprised it's doing something different.
 * [krzysztof] Firefox supports native Map and Set in storage.local
   * [oliver] We were just discussing moving to structured clone to address this case.
   * [rob] That is why it works in Firefox - we use structured cloning.
   * [tomislav] structuredClone is a well established tool for this kind of use case. Would prefer to adopt that here.
   * [oliver] If we can identify enough types that need to be stored differently, it would make sense to just move to structured clone.
   * [timothy] I think that structured clone makes more sense than just solving it once.
 * [krzysztof] Observed that our complicated UIs take a while to load. We don't bundle JS, we have well structured individual files. Would browser vendors be open to some kind of cache warmup? We use JavaScript modules.
   * [rob] Sounds like something browsers could/should do without API changes. Makes sense to do this for background scripts, especially.
   * [krzysztof] Hack solution for an extension is to load these files in the background (e.g. a background tab) to warm the files before injection.
   * [timothy] This is what we do in Safari already; frequently used code is compiled and cached.
   * [krzysztof] This happens when code runs once. Could we warm up the cache?
   * [timothy] Probably something we could do. Default behavior has been to let it happen when the user interacts with the resource.
   * [oliver] Is there a reason why this is more of an issue here than on the web?
   * [krzysztof] Large production websites don't use ESM directly. They bundle scripts.
   * [simeon] Chrome uses a completely different loading path for extensions resources.
   * [rob] If perceived cold startup is a concern, could you add a small script or style that shows progress.
   * [devlin] In Chrome we don't cache extension resources. Artifact of current implementation. Something we'd be open to. I think the extension service worker is cached, but nothing else.
   * [krzysztof] Wasn't sure if it was worth having an issue.
   * [devlin] We've had a few threads about this in the extension mailing list.
   * [oliver] Yeah, but most have been higher level requests. For example, we've had requests to freeze the background service worker instead of terminating.
   * [krzysztof] Would recommend against that. Violates expectations of web script behaviors. Devs don't expect that their context will live forever.
   * [rob] Going back, Firefox has been working on sharing compiled code across pages.
   * [krzysztof] I haven't noticed performance issues in Firefox. Specifically observed in Safari in Chrome.
   * [tomislav] We also preload the action panel content in Firefox when it seems likely for the user to open the panel, when the user hovers over the extension action button.
 * [krzysztof] Can we create new surfaces to communicate with the user? Say a space on the new tab page. Looking for more predictable and dismissable outlets.
   * [timothy] This is an area we'd be interested in and would like to see proposals for.
   * [krzysztof] New tab page is also of interest, but we haven't explored it because we didn't know what kind of interest there would be here.
   * [timothy] This is one of the surfaces we're interested in exploring.
   * [krzysztof] Want to let new users know there's a new feature or resurface a feature a user may have missed. Would be open to a single surface that rotates between extensions. Don't want to be intrusive. Would prefer a place where users are expecting this kind of message.
   * [timothy] We were more interested in it being a user-customizable feature where a user can choose to surface a component from a given extension.
   * [krzysztof] Like some kind of extension widget. Got it. Maybe an iframe.
   * [tomislav] Maybe not iframe; new tab page are heavily optimized.
   * [oliver] Not something we're specifically looking to implement, but would be happy to look at and consider a proposal.
   * [mukul] Doesn't have to be a single thing implemented by every browser
   * [oliver] Would be nice to have a common surface with established expectations.
   * [timothy] Whatever the proposal is; it would need to be very flexible for browser interpretation.
   * [krzysztof] having a common denominator would be useful. Ultimately something is better than nothing.
 * [krzystztof] Does anyone remember “Firefox Collusion”? It was a project to showcase which scripts load other scripts, and other scripts. At the Ad Filtering Dev Summit, there are often presentations that show this kind of concept. Tracking requests and stack traces and showing it somehow. We'd like to have this functionality to effectively block more trackers. A script loaded by a tracker is a tracker as well.
   * [timothy] We have something similar in WebKit. Don't know if it's the same shape as Firefox.
   * [simeon] Do you mean like a HAR file for a page load?
   * [timothy] We have our own resource load tracking data for our tracking prevention feature. If it's useful for extensions, we could consider exposing that data. https://webkit.org/tracking-prevention/
   * [krzystztof] Devlin, in a previous conversation you mentioned something about “resource tainting”?
   * [devlin] We don't have that information.
   * [krzystztof] Not the script that initiated the request? Devtools shows it.
   * [devlin] We have initiator.
   * [rob] That is the document's origin, not the script that had the code that triggered the request.
   * [krzystztof] If performance is a concern, could do this on specific page loads rather than all page loads.
   * [tomislav] We are unlikely to bring back Collusion, but we have a database similar to what Timothy mentioned that tracks resource loading paths. Might be possible to expose that, but will need to look into it.
   * [krzystztof] Are all parties open to exploring?
   * [timothy] Yes, but no guarantees
   * [tomislav] Same.
   * [devlin] We don't surface anything to the extension today, so would want to know more about what you're interested in accessing.
   * [krzystztof] If I can determine that A triggers B, or B is triggered by A, then we can build that map.
   * [timothy] We at least have the data of what triggers what.
   * [tomislav] We have categories of requests, like trackers, social, etc.
   * [krzystztof] but that's metadata classifications applied
   * [tomislav] Yes, but the point is there's some precedent to exposing more data.
 * [david] The MV3 service worker's dev tools are unable to open IndexedDB, whereas the MV2 version was able to do so. Actually, we have an inversion: MV2 devtools did not allow opening storage.local but allowed opening IndexedDB. MV3 devtools allow opening storage.local but do not allow opening IndexedDB. Note: devtools for frontend shows both, but devtools for service worker only shows storage.local.
   * [devlin] Sounds like a bug.
   * [oliver] Storage one surprises me. I tried to make that show in as many places as possible.
   * [mukul] Should someone open a bug?
   * [oliver] Yes please.
 * [david] Chrome-specific: TextDecoder / TextEncoder in Chrome are relatively slow; Faster in WebKit and Firefox. Turns out to be related to small strings. After some threshold the native TextDecoder/TextEncoder is faster in Chrome, but before that it is much slower.
   * [devlin] Sounds like a bug. I don't know about its implementation is to file a bug.
   * [timothy] Under the hood WebKit uses ICU.
   * [oliver] Having a bug with sample data and code would enable us to investigate further.
   * [david] Ran into this issue last year. Also tried before this meeting and wasn't able to reproduce it. With some experimentation, found that with a deep enough call stack and memory used, it could be 4x slower in service workers. Was this known and fixed?
   * [devlin] Don't know. There have been performance improvements around SWs, that may or may not be related.
 * [david] Chrome-specific: Profiling. In MV2 it was easy to run the profiler for the background page. When I open the devtools for the extension service worker, it throws an error.
   * [simeon] Sounds like a question for the devtools team. Speculate that it may be because there is no page.
   * [oliver] Please file a bug.
 * [kiara] `browser` namespace?
   * [devlin] We prototyped it, and tried running, but noticed that extensions relying on webextension-polyfill broke.
     * https://github.com/mozilla/webextension-polyfill/issues/721
   * [rob] The webextension-polyfill introduces Promise support without changing API behavior, except for runtime.onMessage to support Promise return values, because it is heavily relied upon by extensions.
   * [devlin] We're supportive of having a promise version of onMessage. There's a dependency on us implementing that. Once we do, we can turn on browser because the polyfill will be unnecessary.
   * [oliver] Currently enabled behind a flag.
   * [timothy] Do you know how you're going to fix it beyond modifying the polyfill?
   * [devlin] On our side once we add promise support to onMessage, the polyfill will be a noop.
   * [timothy] Would also be ideal if the polyfill can be updated to make it a noop. We made a change in Safari to make it a noop. Forget exactly what the change was.
   * [oliver]
   * [rob] I'd be open to a minor release if it helps.
   * [timothy] The change I made: https://github.com/mozilla/webextension-polyfill/commit/871b49d98968e940011ebf4506028befe9859b0e
   * [oliver] Most of the Chrome Web Store uses webextension-polyfill 0.10.0.
   * [rob] 0.10.0 was published 3 years ago (2022).


### Long Term Direction

 * [simeon] Strategic discussion on where the platform is headed. Topics include event targets, API design principles, declarative vs. imperative trade-offs, and how to align on a forward-looking vision for extensions architecture.


#### Events and live objects

 * [simeon] Fundamentally different event model between extensions and the web. That we do not have event targets, for example.
 * [timothy] I'm interested in getting to a more web-based extension model. We had it before. Clear hierarchy of event targets – browser, window, tab, page. Interested in exploring ways to make our event APIs more hierarchical and event-based.
 * [rob] Are you specifically interested in the event bubbling aspect of this?
 * [timothy] I've been thinking about something where at the lowest level there's a resource type that maps to request events, bubbles up to a live object with a documentId, that has a frame object, that bubbles up to tab, window, global browser object. Fundamentally a different paradigm than what we have today. Organically lends itself to live objects, which we've discussed before, where you could do something like `browser.currentWindow.activeTab.frames[1]`.
 * [simeon] I may have misrepresented your view: I thought you were hesitant about live objects.
 * [timothy] That was Chrome. I am in favor of live objects.
 * [devlin] I am hesitant about live objects. If events are bubbling through events and targets, what does that look like when you've got an event that's propagating and the background context gets torn down?
 * [timothy] You have to retrieve it again; but because events bubble you can listen for it at the top level.
 * [devlin] That eliminates some of the benefits, right? Figuring out how this works with ephemeral contexts is one of the things we'd need to think about and work through.
 * [rob] Question about the previous example. (`browser.currentWindow.activeTab.frames[1]`) This information isn't synchronously available in the process.
 * [timothy] Basically listens for everything and keeps live objects alive. Tries to keep everything up to date.
 * [tomislav] If we promise an API like this, that would mean that we would have to propagate all potential changes down even if extensions do not need this. If at any point you can do `browser.currentWindow.activeTab`, you haven't captured that object. I don't know a non-naive way to approach this.
 * [simeon] I can imagine something where you have to use an accessor in an outer context, but that doesn't align with the kind of fluent API expressed in the example being discussed.
 * [alexei] I am wondering, what inspires this future idea?
 * [timothy] It is more a desire of matching closer how the web works. Not driven by what extensions do today.
 * [rob] Noting that an aspect of live objects is that they are mutable, whereas current extension event parameters are immutable.
 * [timothy] How is this different from service workers?
 * [devlin] Service workers do not listen on live objects; they listen on `navigator.serviceWorker` and do not have state associated with them.


#### Named globals

 * [simeon] Rather than one global, importing specific namespaces.
 * [devlin] `imports {tabs} from ‘browser';`?
 * [simeon] Yes.
 * [tomislav] We already lazily expose namespaces.
 * [krzysztof] Can easily be polyfilled.
 * [carlos]  potential reduced API surface for abuse.
 * [tomislav] and forbid dynamic import
 * [carlos] Yes.
 * [rob] As an extension dev, I'd rather use a browser global.
 * [timothy] I tend to agree. We also populate namespaces on first access.


#### browser.addEventListener

 * [tomislav] Going back to the idea of `addEventListener` on the existing browser namespace, that seems like a pattern that could be adopted.
 * [timothy] Could easily introduce EventTargets for all the browser namespaces. That avoids the potential problems discussed with the more detailed set of live objects.
 * [rob] Would we have an event object with event.details where that property exposes the current value? Or would we want to merge the event properties with the current Event object?
 * [timothy] We'd have to have an `Event` object. Could be a custom event with properties that are exposed directly on the object, not just embedded in the details property.
 * [rob] If there are no conflicts, that would be nice. Seems possible. How would we handle filters
 * [tomislav] `addEventListener` has an `options` object. Could be added to that.
 * [rob] And if we provided chatty events, we could expose filters where developers could narrow down their interest.
 * [simeon] The lack of filters in current extension APIs is one of the things that's bothered me about our current systems.
 * [tomislav] Architecturally, filtering is less important in DOM because everything is happening in the same process.


#### API design principles

 * [simeon] As I think about APIs and potential approaches. Are there ways to forward-declare to allow the browser to guess less often to get the desired outcome? Imperative APIs are more flexible (e.g. webRequest).
 * [devlin] Decided on a case-by-case basis.
 * [simeon] Are there principles we could gather into some “design principals” resource doc we'd have. What would we want to include in such a doc?
 * [devlin] General shape of APIs, thinking of future compatibility, objects instead of single params (to allow future additions), success/failure indication, async methods should return Promise and not promise. Alignment on language (`onclick` vs onClicked).
 * [timothy] Naming consistency. Consistent use of case. Style guide on dos/donts for APIs.
 * [devlin] We have largely been aligning on new API namespaces should always require a permission, even if there is no visible warning.
 * [oliver] May be too much detail, but some conventions around verbiage in a specification.
 * [simeon] For clarity, I was thinking about including this in a design_principals.md in the repo.
 * [oliver] Some of this could also be included in the spec.
 * [rob] Consistency would be my biggest item to focus on. We regularly say “we'll do better” and then do something unique again.
 * [timothy] Design principals are that guidance.
 * [timothy] With so many (new) contributors it is imperative to be consistent.
 * [carlos] Improving the contract between extension developers and the platform. Allowing extensions to signal preferences, that browsers can make decisions independently of other browsers. Allow extension developers to express their desires across that diverse set of implementations.
 * [rob] Can be summarized as “offering information so that the browser has to guess less”
 * [carlos] Intentions from developers
 * [tomislav] Preferences and intentions from developers rather than requests / demand. Give browsers more leeway to decide how to handle that. “I would like access to google.com” vs. “Give me access to google.com this moment.”
 * [timothy] I like that framing.


### Wrap-up discussions

 * [timothy] Final session to review action items, check for consensus on key decisions, and reflect on outcomes from the week. We'll also discuss post-meeting follow-ups, including minutes, and timeline for the next steps.
 * [timothy] 4 better than 3?
 * [devlin] Yes.
 * [tomislav] Yes.
 * [timothy] Thought that we would have issues with filling the schedule, but it filled up pretty well.
 * [tomislav] More relaxed schedule, started relatively later.
 * [simeon] Relax schedule also offers room to schedule breakouts later, follow up on topics after some offline work.
 * [simeon] C.
 * [tomislav] Dev feedback
 * [carlos] More relax, fluent and productive. I like Simeon's 5-minute time checks.
 * [oliver] Think the approach to breaks were nice.
 * [carlos] Clear objectives for issues was helpful.
 * [rob] In some discussion I tried to cut the conversation short to make sure we were interested in solving the problem before proceeding, and clarifying action items. Any concerns with that approach?
 * [simeon] No concerns on my end; moved on before spending time on things we didn't need.
 * [carlos] Would be helpful to have more detail beforehand. Many sections on the wiki had “TBD”.
 * [timothy] I updated the TBDs once I realized they needed to be filled out.
 * [rob] Half way through the week I realized our main github issue did not link to the wiki page that we created later. I've added it, but it may be too late for people who do not regularly participate in our biweekly meetings.


#### Next meetup and goals

 * [timothy] Is Google hosting next year?
 * [oliver] I'm supportive.
 * [tomislav] It might be good to spread locations. Maybe host in Canada?
 * [timothy] Slightly later in the Spring may be better.
 * [devlin] Also consider when TPAC is; this year it is later, so host our next meeting later so that sufficient time has passed since TPAC.
 * [timothy] Next year might be later as TPAC will also be later next year.
 * [mukul] Should also keep in mind other conferences happening around the same time. Maybe conflicts with I/O, WWDC, etc.
 * [timothy] April may be the sweet spot.
 * [devlin] Don't like doing it the last week of a quarter.
 * [devlin] Should we talk about what we want to have done by TPAC? (simeon:yes) We should write more spec text? How much do we need to have done?
 * [simeon] I can follow up after I sync with my standards folks.
 * [oliver] Would like to have submitted something and have started the process by TPAC
 * [devlin] Agreed
 * [simeon] +1
 * [rob] On testing, the ability to run extension tests in WPT, so that tests can be shared and run. WPT bots takes care of synchronizing tests across repositories, having the ability to run them (even if manually) would be useful.
 * [devlin] Good call.
 * [krzysztof] I'd like to get script evaluation tests created.
 * [tomislav] We're actively working on this with Chrome. We have a meeting scheduled with the Browser Testing and Tools group for their next session. Kiara and I will join. Would like to have tests running across multiple browsers with a design that's aligned across all browsers by TPAC.
 * [krzysztof] Can we align on getting DNR in tests?
 * [timothy] Supportive of getting some DNR tests built out.
 * [devlin] Sounds reasonable.
 * [tomislav] I know WPT has a dozen different domains that can be used for testing.
 * [krzysztof] Ad blocker community should be able to put together a decent set of tests.

 * [simeon] We can talk a bit more about building out our spec. What areas are we interested in building out?
 * [timothy] I'm planning on working on the background manifest property
 * [devlin] Specifying the behavior of the extensions origin, permissions field.

 * [rob] Planning to review the meeting notes and extract action items. How would you like to be notified of action items?
 * [tomislav] Tag us in the doc.
 * [rob] Nice part of our approach to notes this week is that we're already ready for publication.
