# 2025 WECG Berlin F2F, Public Notes, Mar 27

Thursday, the third day of the four-day face-to-face meeting in Berlin (announcement: [#759](https://github.com/w3c/webextensions/issues/759)). Agenda: https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination


## Agenda

 * [WG Discussion](#wg-discussion)
 * [Upgrade Permissions](#upgrade-permissions)
 * [DNR: What's missing?](#dnr-whats-missing)
   * [Issue 439: Proposal: Add filter for DNR modifyHeaders?](#issue-439-proposal-add-filter-for-dnr-modifyheaders)
   * [Issue 468: [DNR] Redirect rule does not allow applying other redirect rules to the resulting request](#issue-468-dnr-redirect-rule-does-not-allow-applying-other-redirect-rules-to-the-resulting-request)
   * [Issue 493: Support for redirect-only rules.](#issue-493-support-for-redirect-only-rules)
 * [Action & Sidebar UI](#action--sidebar-ui)
   * [Issue 198: Proposal: action.default\_area=navbar and action.default\_area=hidden](#issue-198-proposal-actiondefault_areanavbar-and-actiondefault_areahidden)
   * [Issue 128: Unified sidebar proposal](#issue-128-unified-sidebar-proposal)
 * [Lifecycle & Matching](#lifecycle--matching)
   * [Issue 138: Proposal: let content scripts listen for event to detect when the extension is unloaded (for various reasons)](#issue-138-proposal-let-content-scripts-listen-for-event-to-detect-when-the-extension-is-unloaded-for-various-reasons)
   * [Issue 763: Proposal: Add topFrameMatches / excludeTopFrameMatches](#issue-763-proposal-add-topframematches--excludetopframematches)


## Attendees

 * Oliver Dunk (Google Chrome)
 * Devlin Cronin (Google Chrome)
 * Simeon Vincent (Mozilla)
 * Rob Wu (Mozilla)
 * Tomislav Jovanovic (Mozilla)
 * Carlos Jeurissen (Jeurissen Apps)
 * Mukul Purohit (Microsoft Edge)
 * Timothy Hatcher (Apple)
 * Maxim Topciu (AdGuard) – starting from [dNR: What's Missing?](https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination#r3)
 * David Tota (AdGuard) – starting from [dNR: What's Missing?](https://github.com/w3c/webextensions/wiki/2025-Berlin-F2F-Coordination#r3)
 * Kiara Rose (Apple)
 * Casey Garland (Capital One)
 * Jordan Spivack (Capital One)
 * Krzysztof Modras (Ghostery)
 * Jan Biniok (Tampermonkey)
 * Oleksii Levzhynskyi (Grammarly)


## Notes


### WG Discussion

 * [simeon] Advance the conversation around creating a formal Working Group. What process do we need to follow? Who would chair? How would the Community Group and Working Group coexist—could the CG act as an incubator? Let's establish a plan for governance, scope, and collaboration going forward.
 * [simeon] Desire is to have a Community Group like we have today, and a Working Group.
 * [timothy] Community Group is more open to external contributors, whereas a Working Group is more limited to invited experts.
 * [devlin] Are there other examples where a WG and CG co-exist?
 * [simeon] Privacy groups.
 * [simeon] In formal working groups, there are three levels with varying levels of openness in meetings: public, group, team. What would change here is that the chair would have to dig in the W3C policies so we can follow the documented procedures. A WG has more formality, which is partly why I don't like to convert this CG, since our current practice encourages broad participation.
 * [timothy] Agree, I'd like to keep that.
 * [oliver] Our CG has multiple mailing lists. public-webextensions and internal-webextensions
 * [simeon] public is public, internal for all W3C members who have signed up. We also have teams-webextensions.
 * [oliver] What is team-webextensions?
 * [simeon] W3C staff and invited experts. We asked a mailing list for a leads list, and this is what we got.
 * [oliver] One of the questions in the WG charter template is to choose the venue for discussion. I recommend going with Github issues over mailing lists given our good experience with that format.
 * [simeon] Agreed.
 * [simeon] The most substantive change is the way we publish technical reports, which have more formal requirements.
 * [oliver] What is the point in time where we publish something? Are we basing it on the manifest version, for example?
 * [simeon] To some extent for the editor to decide. Also something we would need to decide, the frequency of publication.
 * [oliver] Is a living standard possible? I'd like to lean towards that if there is an option.
 * [devlin] I'd like to not tie to manifest version - we'd like to publish more often than updating the manifest version.
 * [simeon] Expect that the biggest change for publishing updates will be the need to call a W3C API to formally publish drafts as we iterate on them.
 * [oliver] Sounds like we'd like to retain the flexibility of updating content as needed, without too much hurdles to publish outdated content.
 * [krzysztof] How can the community group support the WG? Does it preclude CG members from contributing to the specs from the WG? Or can we establish a process where external contributors can submit PRs to the spec and be accepted?
 * [simeon] The way I see it - CG is focused on discussing substantial changes, and the WG on the execution on what has been discussed. When we have a proposal in the CG right now, that it would support specification in the WG.
 * [carlos] What are the objectives of creating a WG? What are you trying to achieve with a WG?
 * [simeon] A limitation of CG is that it cannot produce formal standard specs, WG can.
 * [rob] Is the assumption of community members being unable to contribute true? Why would contributors not be able to propose a change and then be accepted by an editor.
 * [simeon] Patent obligations, copyright, licensing requirements, etc.
 * [oliver] We see opportunities of collaborating with other working groups. There is no hard requirement for the group to become a WG, but WG has a higher status and credibility that can help with involving other relevant specs.
 * [oleksii] Can contributors add a disclaimer to give up the rights necessary to allow the content to be merged in the spec?
 * [krzysztof] That is the purpose of the invited expert role.
 * [simeon] Another in-between is an Interest Group, which is a more formal version of CG.
 * [rob] Any advantages in terms of spec writing?
 * [simeon] Interest groups are still not empowered to produce standards.
 *
 * (Simeon going round the table) Any concerns about WG?
 * [devlin] (Google) I cannot speak to the legal aspects; Personally open to exploring WG.
 * [mukul] Fine.
 * [simeon] Capital One folks?
 * [casey] (Capital One) How would it impact the WECG? E.g. would it impact the frequency?
 * [simeon] The existing biweekly public meeting cadence will continue. I would like the change on the WECG side to be null.
 * [timothy] Not expecting changes. We already have Leads meetings in the alternative weeks.
 * [] Excited about potential positive impact on developers.
 * [carlos] Is this mostly about getting a spec down?
 * [simeon] A WG has specific deliverables; more progress on specification is needed for creating a WG.
 * [] Do you see the WG as something with an end date?
 * [simeon] A WG has a required end date; however it is extremely common for a WG to be renewed. A WG term is 6 months to 2 years, and can be extended.
 * [carlos] How would the creation of a WG result in more spec work, since the CG has currently not made much progress on spec work? Does the creation of a WG result in more time allocation?
 * [simeon] No guarantees, but this can help with organizational buy-in and is making more of a commitment towards deliverables.
 * [oliver] Similar.
 * [rob] We (Firefox) are favorable towards the direction of WG.
 * [oleksii] If a WG is established for 6 months to 2 years. What is the expected outcome? E.g. a new manifest version?
 * [simeon] I don't think that a new manifest version would be desired outcome. A specification of a common platform that underpins WebExtensions across browsers, and a test suite to automatically verify that.
 * [oleksii] Is it not about introducing breaking changes?
 * [simeon] On the contrary, reducing inconsistencies.
 * [timothy] Documenting what we already have, and integrating community proposals in the spec.
 * [krzysztof] Wondering how subtle differences will be accounted for in the standard.
 * [simeon] It is unusual yes. I think that we should spend time and energy on approaching this.
 * [krzysztof] Overlap with WebDriver spec?
 * [simeon] The way I see it, the Browser Testing and Tools group allows for other groups to extend their spec.
 * [krysztof] An extension standard would also help them; currently overlapping parts are explicitly not specified. Having an extension standard can facilitate cross-referencing.
 * [rob] You mentioned overlapping specs and I know that you contributed the extension loading part to the WebDriver spec. Are you referring to what held you back of being more detailed, or is this about something you observed in that  group?
 * [krysztof] For example, evaluating scripts in a web context. They could not include information about web extensions contexts because that doesn't exist in existing specs. That in turn creates implementation differences in the platform. Chrome integrated extension into their WebDriver support, but Firefox passed on it. Having those concepts in a standard would enable WebDriver editors to reference and include those ideas.
 * [simeon] Apple folks?
 * [timothy] (Apple) We have been pursuing a working group internally and are near approval.
 * [simeon] Looks like we have clear consensus on this being useful.
 * [casey] What happens if some core members do not get approval to proceed with a WG?
 * [simeon] Depends on the concerns. We would likely try to work through the objections, which may affect the scope of work.
 * [oliver] To add to what Devlin said before, we are having initial conversations internally, and final approval can only happen when the charter is finalized. That having said, I don't expect major issues.
 * Next steps: finish draft of charter.
 * **Action Item:** Oliver to drive finishing draft of charter for WG


### Upgrade Permissions

 * [simeon] Explore proposals to improve the extension permission model, especially for onboarding and updates.
 * Relevant issues/PR:
   * [Issue 711](https://github.com/w3c/webextensions/issues/711): Proposal: Enable changing the permissions for only new user
   * [PR 788](https://github.com/w3c/webextensions/pull/788): Proposal for "Hybrid Permissions"
 * [simeon] Issue 711 - issue generally is that extension updates with new permissions prevent users from continuing to use the extension. This topic discusses a way to introduce permissions that are granted at install time but optional on updates.
 * [oleksii] Big challenge for extensions with an existing user base is introducing features dependent on new permissions. Would like new users to have the complete experience, and migrate existing users over. [PR 788](https://github.com/w3c/webextensions/pull/788) proposed a way to request permissions for new users, but allow existing users to update without requiring the permission to be granted. The exact name does not matter. The desire is for the permission to be granted without it being removable. There are also permissions that can currently not be optional, only in (required) permissions such as declarativeNetRequest and devtools.
 * [simeon] Immediate question that comes to mind is - how is this different from the optional-only concept?
 * [rob] They are opposite.
 * [oleksii] From the user perspective, a post-install permission request, after the user has just approved an install prompt is not ideal. Users may also miss the notification and fail to grant the necessary permissions.
 * [rob] Do we need to discuss use cases any further? If we all agree that this is a problem, can we proceed to solutioning?
 * [devlin] I think it's an issue we should address, but I have a different solution in mind. This is trying to solve a challenge with how browsers present UI. Doesn't necessarily need a manifest change. We want to move to a world where all permissions can be toggled by a user. Chrome allows users to toggle all host permissions. Want users to be able to control all permissions. What if, rather than introducing a new key, what if we just adopted the optional behavior for permissions in the `permissions` field? On install, you get the declared permissions. On update, new permissions entries are treated as optional (not granted by default)
 * [rob] Developers would need to opt in, or else extensions designed without this model in mind can break.
 * [devlin] A new permission in the permissions key would also mean new code to interact with that permission. For developers, would anyone prefer having your extension disabled when a new permission is added? (all: laughs) Okay, about what I expected.
 * [jan] I like the way Firefox handles things today. If a user doesn't want the new permission, they can stay on the old version.
 * [devlin] Discussed a bit on the first day. Don't think that's something we'd do in Chrome.
 * [jan] Hard for users to determine what permissions are necessary. Having to always check what declared (required) permissions are available is unnecessary overhead.
 * [devlin] Don't have to solve every permission being toggleable as part of this discussion. There's power in defaults. Toggling is likely a power user feature. TamperMonkey handles some of these cases well, e.g. prompt notifying the user that host permissions are required. Technically possible to make any permission optional today via enterprise policy.
 * [jan] It's fine to make all permissions optional as long as there's a way to give it everything.
 * [devlin] Extension should message the user to make it clear when the user doesn't give them the permissions needed. For example, if you install a camera app and deny the camera permission
 * [oliver] Concern: extension devs would have to keep track of the full history of changes to determine which permissions may potentially be missing.
 * [devlin] Concern no matter how we tackle this. If you introduce a new manifest key, that would still be an issue. I'm curious if anyone wants their extension to be disabled.
 * [rob] Starting from the wrong premise. Of course devs want a better experience. Firefox's approach is already better than Chrome's. The bar for improvements is higher than “disabling extensions completely” vs something slightly better.
 * [oliver] Better question might be are there any devs that would prefer Chrome's behavior over Firefox's
 * [krzysztof] All approaches to adding permissions are scary today. Idea of making all permissions optional is interesting but very complicated. Take the tabs permissions – there are hundreds of places where this capability is assumed. How would you meaningfully make that optional?
 * [carlos] Extensions have different types of permissions: core permissions (really required), helpful permissions (that can be disabled), and very optional permissions (requested by the extension in some cases).
 * [rob] By permissions that can be disabled, do you mean what would be described here as “hybrid”?
 * [carlos] Yes. Browsers could handled these differently, but this would give a clear way to communicate intentions with the browser.
 * [devlin] Say we introduce this new field & fast forward 5 years, is any extension going to add a new permission to the ultra required ones?
 * [oleksii] Yes, I expect so. E.g. permissions without warning.
 * [rob] And if a permission had a warning, the extension would be disabled. I think that developers aware of the nuances would not add new permissions with warnings.
 * [devlin] Agree that Firefox has a different consideration. Given that we don't want to do that on Chrome and that most devs try to target multiple browsers…
 * [rob] Why not in Chrome?
 * [devlin] We want extensions to be up to date. Same reason we want users to update the browser. Should be as easy as possible to have the latest security improvements, minimize the number of users lingering on older versions.
 * [tomislav] You don't disable Chrome if people don't update it.
 * [devlin] We're closer to that than you may expect. We get very noisy and have considered forcing restarts.
 * [carlos] Can't customize behavior for every different browser/store. New key keeps backwards compatibility.
 * [rob] Would suggest pursuing this with a new key, but using a boolean rather than an array. Flip the default value of the boolean in a future manifest version. More backwards compatible.
 * [timothy] Like that approach. Gives a clear signal that they're opting in.
 * [devlin] Open to having a boolean. Biggest thing I want to avoid is more sets of permissions. To Carlos' point, I understand that there are multiple different sets of permissions, but don't think we need discrete fields for each.
 * [carlos]
 * [rob] That's separate from making everything optional
 * [carlos] Starting with a boolean would mean you miss this information. It's all about better expressing intent as an extension developer.
 * [rob] I understand there are permissions that the extension really wants. For example, with activeTab the browser does not have enough information to tell what the extension's intent is. There's a difference between an extension that really needs to run everywhere or if it just can run everywhere, when the user chooses to click on the extension button for a specific task.
 * [carlos] I can try to write something up to be more clear.
 * [devlin] Concern is that browser UI could become too overwhelming. Don't think users should see 3 sets of permissions on the extension's settings page. Want to move towards a world where users can toggle permissions even if the extension doesn't want that because user choice comes first.
 * [carlos] Extension may not be able to do anything in that case. Better to not have it installed at all.
 * [devlin] Extension can uninstall itself if it truly feels that way.
 * [rob] Discussion of everything optional should be tabled for now. We should not block on that to resolve the current problem.
 * [oleksii] .
 * [devlin] That's the argument that says we shouldn't make it the default, leave `permissions` as fundamentally required. But extensions that have an established user base will almost never touch this field after getting a notable user base. If that's true, then we've effectively done that by changing the behavior of the key.
 * [simeon] Expect that the big challenge with reusing the existing field is a change in developer expectations.
 * [devlin] Right, need documentation, messaging, etc. Could also be addressed with a boolean key.
 * [rob] What about host permission?
 * [devlin] Same approach.
 * [rob] In Firefox we tried not granting host permissions by default in MV3, but that resulted in lots of friction, so we grant host permissions by default at install. New host permissions do not prevent updates, but they are currently not granted on update. The new key can be used by extension devs to opt in to preventing updating until the user opts in.
 * [devlin] Then you can have the unspecified case be the current behavior.
 * [krzysztof] What kind of support timeline would this have? Say ESR releases.
 * [devin] Don't think that's any different from how you'd approach supporting old versions. Set a minimum version.
 * [rob] Sounds like we are all aligned on a new boolean.
 * [timothy] Yes.
 * [devlin] Maybe an enum in case we want to have more states.
 * [rob] In Firefox we would already have three states, with host permissions (not) granted on update as third state, as discussed before.
 * [oleksii] Would it make sense to simplify permissions in MV4 to reduce the number of fields?
 * [devlin] I think we'd change the schema for permissions in MV4. One thing we've generally aligned on is having permissions justifications in the manifest. But that's some time off.
 * [rob] To recap, we aligned on a new manifest key with an enum value.
 * [oleksii] Ask that if we go this direction, permissions without warnings are auto-granted.
 * [devlin] That makes sense.
 * [rob] I'm leaning towards only applying the “not granted” behavior to permissions with warning.
 * [oleksii] I'll create a PR with a new proposal.
 * [carlos] Do we have a sponsoring browser for this proposal?
 * [rob] I'm willing to sponsor; I think that extension developers would see most value for this in Chrome given their current behavior of disabling extensions.
 * [devlin] Accepting patches, but cannot prioritize its implementation ourselves.
 * [timothy] We will eventually implement it.
 * **Resolution:** Chrome, Firefox, Safari supportive of a new enum field to customize permission granting behavior on update to address issue 711
 * **Action Item:** Oleksii to create proposal PR for issue 711.


### DNR: What's missing?

 * (13:30)
 * [simeon] Discussion on limitations and missing features in `declarativeNetRequest`, with a goal of identifying browser support and potential sponsors for improvements.
 * Relevant issues:
   * [Issue 439](https://github.com/w3c/webextensions/issues/439): Proposal: Add filter for DNR `modifyHeaders`?
   * Issue
   * [Issue 493](https://github.com/w3c/webextensions/issues/493): Support for redirect-only rules.
   * [Issue 783](https://github.com/w3c/webextensions/issues/783): Conditional enabling/disabling of DNR rules.
   * [Issue 694](https://github.com/w3c/webextensions/issues/694): Unlike webRequestBlocking, DNR rules are not applied to redirected requests — should this behavior be reconsidered?
   * (the last two issues were not discussed due to time constraints; topic may be scheduled tomorrow)


#### [Issue 439](https://github.com/w3c/webextensions/issues/439): Proposal: Add filter for DNR `modifyHeaders`?

 * [carlos] [Issue 439](https://github.com/w3c/webextensions/issues/439) (modifyHeaders filter) - no progress. What's next?
 * [rob] Status is: patches are welcome? Implementation-wise probably feasible.
 * [timothy] Proposal would be welcome.
 * [devlin] Someone on the Chrome extensions team is slowly working on this.
 * [timothy] One gripe, the proposal proposes `match_all` whose snake_case syntax is inconsistent with the other properties that use camelCase.


#### [Issue 468](https://github.com/w3c/webextensions/issues/468): [DNR] Redirect rule does not allow applying other redirect rules to the resulting request

 * [maxim] I showed example to Rob; both rules have broad conditions and redirect actions that have removeParams.
 * [rob] DNR is based on conditions. If there's a redirect rule, that will be the final rule applied. In this example, all URL filters could match and cause parameters to be removed. The current result is that all-except-one of the redirect doesn't get applied. There is an understandable interpretation of the rules that would have all of them applied. Does Safari have `removeParams`?
 * [timothy] Not sure offhand. (Edit: We do.)
 * [oliver] Would it potentially work if we treated removed params as a condition?
 * [rob] Before approaching solutions, is this a case we'd want to solve? I think yes.
 * [oliver] What is the impact of not having this on AdGuard?
 * [maxim] Multiple rules are generic, should work together with more specific rules to ensure multiple websites aren't affected. It's hard to fit everything into a single rule as previously suggested in this issue.
 * [devlin] Why doesn't the second redirect rule apply after the redirect is taken?
 * [rob] After the first redirect is applied, the conditions for the second rule no longer match.
 * [krysztof] We have coincidentally encountered the same issue in Firefox. We solved this in our case to merge all removeParams options together in one rule.
 * [rob] That would work if conditions are overlapping, but wouldn't if not.
 * [krysztof] For webRequest, not DNR.
 * [maxim] We have multiple conditions, e.g. resourceTypes and exclusions that prevents us from merging multiple in one.
 * [devlin] I think that this makes sense to solve.
 * [timothy] We do support removeParams in Safari.
 * [rob] Your implementation predates DNR though, right?
 * [timothy] We added support to make it DNR compatible, but don't know the specific details.
 * [rob] Can we create a test case?
 * [timothy] I can try that, but don't block on me.
   * [timothy] We also apply only the first rule.
 * [devlin] There are a couple different types of conceptual redirect actions. On one hand: Make an example.com request go to a different domain. On another: tweak this existing request. We could look for combinable actions and apply all of them.
 * [krysztof] Not all are combinable. For example, block.
 * [oliver] Could we have a new action type, like safe redirect?
 * [devlin] Was thinking about that, but what about other cases like modifyHeaders?
 * [rob] modifyHeaders can apply multiple times. Normally if you redirect elsewhere it could match other rules.  … Right now, problem is that when you match the first request it executes the action. You're suggesting adding a field to make them combinable?
 * [devlin] Or, following oliver's suggestion, introduce a new type of action that is inherently combinable.
 * [rob] How would extensions like to do this? Any preferences?
 * [maxim] Both approaches could work.
 * [krzysztof] Neither will be reliable during a transition period. It will always generate some breakage. If we make this a separate action, what if there's another redirect rule that should apply to the new URL?
 * [rob] It's a new request, so all rules will apply again. An alternate option is after an action has been executed for a specific request, opt out of the redirect chain. Not a perfect solution: could create an issue where redirecting to remove an affiliate goes to a new URL that introduces a new affiliate.
 * [oliver] Is it enough to say it opts out of the next redirect in the chain?
 * [devlin] Real weird, hard to predict, necessitates more rules.
 * [rob] Another option: If the redirect action didn't change the URL, go to the next matching action.
 * [devlin] Not backwards compatible.
 * [rob] Could add a flag to control application of the rule in a backwards compatible way. Can you think of a case where an extension wouldn't want this behavior?
 * [devlin] Only tautological cases. Currently highest priority rule wins, if we did this and a not-highest priority rule wins, that'd be a tautological violation. Having a new action type seems explicable and clean. Also okay with having a property on the rule. Are there times where cases with, say, remove param, where you don't want it to be combined with other actions?

   Modify headers will always apply matching rules in a defined order. With something like remove param, would we always want those to be combined? If so, having a property would mean devs have to just always include the param.
 * [rob] Should only be combined if it's the only modification in a redirect. Don't necessarily think we need a new property if the expectation is to just drop it. Argument against a new action is that it's not unique to params. Upgrade scheme could also apply: that case is resolved by having the upgrade be a lower priority. Do we want to introduce a new action when we encounter a redirect?
 * [devlin] Would probably be a broader category of combinable redirect.
 * [oliver] Eventually has to be implemented as a redirect, but individual rule matching doesn't have to apply each separately
 * [krzysztof] Could be cases where there are multiple rule authors that aren't actively coordinating.
 * [oliver] Should learn from past like case sensitive checks, where we had to change the default.
 * [krzysztof] Not feasible for adblockers to try to determine which rules can be combined.
 * [rob] Inclined to change the behavior to something developers can expect.
 * [devlin] Would it break anything to make any redirect action – Not sure how to avoid breaking things. Scheme, port, path, target, query params
 * [rob] Could automatically include removeParams in the condition.
 * [devlin] That would force a redirect every time. If you had 7 redirect rules that remove params, apply each separately exhausts the redirect limit and is more expensive to execute those requests. Two questions. With something like remove param, could we just make that change? Say next version always applies remove params.
 * [rob] could do it in Canary-only for a few cycles?
 * [devlin] Too hard to see the effect, too many moving parts. Would prefer to send out an email and ask “if we change this, does it break you?” If no one replies, we're good.
 * [oliver] Could we do an origin trial?
 * [tomislav] Doesn't tell you if it breaks people that don't opt in.
 * [oliver] If AdGuard tries, it doesn't tell us about others, but it does tell us about AdGuard.
 * [devlin] Could do that to gauge changing the default, but need outreach here.
 * [krzysztof] Do you guarantee the order of the rules? Say we have multiple remove params, can I be sure that one rule will always apply first?
 * [oliver] Order of rules with the same action and priority is undefined.
 * [krzysztof] Having all of them apply best matches expectations, can't do it the other way around
 * [rob] Are we converging on trying to remove them all at once?
 * [devlin] Going that direction, but we should do outreach. Should also consider where else this could apply.
 * [rob] Don't think we should apply this to append, could go on forever.
 * [devlin] Why?
 * [rob] Say you have a rule with abc and you drop b, you then match c. Removing all params at once makes sense because
 * [oliver] I think you're saying: do we match on the initial request with an initial set of query params…?
 * [devlin] Common case: take the original URl, take all matching removeparams, that's the output url. After that it goes back into DNR and looks for more matching rules. If you have one that happens to match, it becomes part of the redirect chain. That's fine, you matched the new URL, not the original URL. If you had a match on abc and not “a not b c”
 * [rob] Could limit number of redirects to things that are likely to stack together.
 * [rob] If removing a param could match other conditions, then we may fail to apply rules that should have applied.
 * [devlin] This isn't a new problem, though. Don't we already have this with headers?
 * [krzysztof] Once you've finished removing the params, you trigger a redirect and then re-check matches.
 * [rob] Say you remove Y if the param contains X, but not Z. Then there's another rule that drops Z. Point is removing a param can change conditions. Not safe to assume you can remove params together.
 * [devlin] Also applies to headers, right?
 * [rob] How do you solve that? We haven't implemented matching headers yet.
 * [devlin] I think we look at the initial state and assume everything else matches.
 * [krzysztof] Doing multiple passes may not be an issue if you're removing params. There aren't that many remove params rules. Separate index may not be such a big problem.
 * [rob] Comment about scanning makes me wonder if we should allow rules to reference other rules that should be considered.
 * [devlin] Don't think that will scale.
 * [oliver] Seems like both issues we're discussing are subtle changes. Don't think doing one prevents changing to the other in the future.
 * [rob] To address the issue of conditions not really matching, we could introduce a property to allow extensions to specify whether an initially matched condition should still match after other transformations.
 * [oliver] If there's minimal risk to having the behavior, let's not add a property?
 * [rob] Let's create a proposal and discuss it there.
 * [oliver] Would like to get some real word data on how this is working.
 * [rob] Are you not worried about mis-applying rules?
 * [oliver] I think we have the same issue with header rules and so far it hasn't been an issue.
 * [devlin] Think we should post to the group to raise visibility and gather feedback. Ask the community what issues this might cause.
 * [krzysztof] Just checked EasyList, they have a total of 240 remove param rules. They seem to be on the simple end.
 * **Resolution:** Explore feasibility of solving issue 468 by changing DNR to apply all removeParams rules at once.
 * **Action Item:** Oliver to solicit feedback from ext devs to determine feasibility of applying multiple removeParams by default.


#### [Issue 493](https://github.com/w3c/webextensions/issues/493): Support for redirect-only rules.

 * [maxim] What should be done next to progress this issue?
 * []
 * [krzysztof] We could come up with a solution, but you may not like it.
 * [devlin] We discussed a solution last year, just haven't had bandwidth to implement.
 * [krzysztof] Kindly request you prioritize this as it's about website breakage.
 * [rob] Can we generalize this?
 * [devlin] I think this is the generalized issue.
 * [oliver] Why don't allow rules work here?


### Action & Sidebar UI

 * (14:30)


#### [Issue 198](https://github.com/w3c/webextensions/issues/198): Proposal: action.default_area=navbar and action.default_area=hidden

 * [carlos] Allow extensions to express their preference for the location of the extension button. Firefox already puts the button on a different location if requested. Even if browsers do not use this information right now, it could also be used to inform the browser on the request to be added to pin an extension button. Chrome used to support pageAction to inform where the button was shown (next to the address bar), but it was dropped at some point.
 * [oliver] Proposal only makes sense if the browser is likely to change their UI. Would we show “this extension wants to be pinned”?
 * [devlin] No.
 * [carlos] Edge displays open sidebar extension. An icon like that could also be used for a popup. Currently for the extension menu it's not clear that there is or isn't a popup attached to it.
 * [devlin] Seems orthogonal to this key. Agree that it's a pain point that it's unclear what clicking the action would do, how does that relate to default_area?
 * [carlos] Allows you to signal intent.
 * [rob] So you want to express that the extension button is an important part of the extension, and not e.g. auto-generated by the browser.
 * [timothy] We can mostly infer that.
 * [devlin] If you're showing indication, we wouldn't want to conditionally show that it will open a popup based on something that's not a popup.
 * [krzysztof] What about the argument of giving user's choice?
 * [devlin] User already has the choice to click the pinned button.
 * [krzysztof] They have to know about that.
 * [devlin] Yes.
 * [krzysztof] User testing has shown this is difficult for users to find and use.
 * [devlin] Concerned about preserving user choice.
 * [carlos] Consider installing an app. You have to add multiple screens to see all the apps you have installed.
 * [devlin] Conflating multiple things. One is an API. manifest key. (...) defaults. With respect to the API, we are not going to allow extensions to take over user control. Agree that it's harder to use, but does not fundamentally break.
 * [devlin] Do you want any of your extensions to be hidden?
 * [carlos] Yes, some are useful in the background, some are important in the foreground.
 * [devlin] Would you actively tell users to hide the extension button? Or if you had an unpin, would you call a method to unpin it?
 * [carlos] That would advocate for the extension to be pinned by default.
 * [rob] Are there cases where you would actively not choose to put yourself in front of users? The thought behind Devlin's question is that most extensions would probably consider themselves to be important.
 * [carlos] For some extensions, yes. Being part of the install flow would be an improvement there.
 * [devlin] If the default was pinned, is that a good state? If I made it so all extensions are pinned by default, would that be okay?
 * [carlos]
 * [krystzof] How about Safari's default? Show the first few, and then hide additional one. What's the average number of installed extensions?
 * [devlin] Relatively few.
 * [krzysztof] Maybe that's fine then.
 * [devlin] Hesitant with key because it includes browser UI-specific parts in the extension UI. navbar may be browser-specific.
 * [carlos] Goal is to communicate intent and give options. Ultimately its the browser's choice what to do with the data.
 * [oliver] I get the idea of offering to pin some but not all. Don't know that it makes sense to add a key that doesn't do anything.
 * [devlin] I think it's valuable to have consistent behavior for extensions. Don't want some extensions to appear in once place and some in another.
 * [rob] Get that the current default is too hidden. But if a user installs multiple extensions, you still hit the situation where you have to tell the user what to do. Might solve for the majority, but doesn't solve for everything. May not be an API issue, it's a browser UI issue.
 * [krzysztof] Never a good moment to do this. Onboarding flow, permissions flow, etc. are already occupied.
 * [jan] Would it make sense to show this in the installation dialog?
 * [krzysztof] How many choices do you want to expose during the installation flow?
 * [devlin] Exactly. Agree that there's a discoverability issue with the current flow.
 * [krzysztof] What about allowing the extension to pin itself with an API?
 * [devlin] User gesture is a low bar.
 * [rob] Are there other ways to get the desired outcome? Say “yes pin, no, remove extension”
 * [devlin] oof
 * [rob] Trying to minimize abuse.
 * [devlin] Personally okay with prompt, not sure if Chrome UX would be.
 * [krzysztof] Would it be possible to pop the extension out of the menu to remind the user it's there?
 * [rob] action.openPopup()
 * [simeon] That's essentially how the installation flow works right now – the extension emerges from the menu, hides inside it when the notification is dismissed.
 * [krzysztof] Pop it out once a week to remind users it exists.
 * [carlos] Devlin, could you ask the UX team?
 * [devlin] Yes. I'm surprised that the people here did not want to be pinned by default.
 * [krzysztof] To be clear, this is a very big need for us.
 * [oliver] We have heard this feature request before.
 * **Action Item:** Devlin to ask Chrome UX whether it is acceptable to allow extensions to prompt for the button to be pinned to address issue 198.


#### [Issue 128](https://github.com/w3c/webextensions/issues/128): Unified sidebar proposal

 * [timothy] We discussed this before; we agreed that `sidebar` would be the ideal name and that perhaps we should alias at some point.
 * [carlos] What needs to be done to get there?
 * [timothy] Safari supports introducing a new name / alias.
 * [oliver] Are we all aligned on a common namespace?
 * [devlin] In a perfect world, we would have a common namespace. Would like to see a mapping of what the properties should do. That could unblock us. If there is no way to map, that would be an issue.
 * [rob] If someone were to come up with a mapping, would Chrome be willing to add `sidebar`.
 * [timothy] Since we looked at implementing `sidebar_action` / `sidePanel`, we are willing to drive a proposal.
 * [simeon] Would Firefox be open to introducing the concept of a contextual side panel? Want to make sure there's consensus on the direction first.
 * [rob] Open to it. I'm looking forward to what Timothy comes up with, and align in Firefox to have cross-browser compatibility.
 * **Resolution:** Chrome, Firefox, Safari in favor of a unified `sidebar` namespace if feasible.
 * **Action Item:** Timothy to create proposal on unified sidebar API to supersede sidebarAction and sidePanel.


### Lifecycle & Matching

Discuss support for top-frame matching/exclusion and lifecycle event proposals.

 * Two topics
   * Lifecycle events ([#138](https://github.com/w3c/webextensions/issues/138), [#353](https://github.com/w3c/webextensions/issues/353)): Proposals like `runtime.onInvalidated` to detect when an extension is unloaded.
   * Top-frame matching ([#763](https://github.com/w3c/webextensions/issues/763)): Proposal for `topFrameMatches` / `excludeTopFrameMatches` to give extensions better control on the top-level document content script injection.


#### [Issue 138](https://github.com/w3c/webextensions/issues/138): Proposal: let content scripts listen for event to detect when the extension is unloaded (for various reasons)

 * [carlos] Created PR at https://github.com/w3c/webextensions/pull/792.
 * [rob] Typically when an extension is loaded or unloaded, an extension breaks. For `runtime.onInvalidated`, when would it fire? Before invalidation, after, during?
 * [devlin] In Chrome, you'd get the event but we can't make any guarantees about extensions APIs being available when you receive. After the event is dispatched from the browser process, we'd unload the extension from the browser process. Even though the renderer would allow it to be called, it would then fail with unknown extension.
 * [rob] If we specify this, what would be the order? Can we say anything will work?
 * [devlin] Would say you can't rely on any extension capabilities once this is fired. Things aren't guaranteed to be removed, but they also aren't guaranteed to work.
 * [timothy] We don't unload content scripts.
 * [rob] Wonder what we should specify for this event.
 *
 * [rob] Would you be okay with keeping the extension context alive as extension work is done?
 * [devlin] We already do in Chrome.
 * [krzysztof] can we get one tick? Reminds me of the Firefox bootstrap extensions days.
 * [rob] There's a hack available: extensions can execute code in the MAIN world. If extension devs are okay with one tick, I'm fine with that.
 * [devlin] You could have async cleanup to do.
 * [rob] For example could have a Promise that need to resolve before you can reach a stable state.
 * [devlin] If we want to give developers time to clean up, it seems reasonable that some of that could be async.
 * [krzysztof] So you could return a promise from your event handler?
 * [devlin] Moot for us, but yes.
 * [rob] I can see sync or async resolution. But don't need to spend too much time on that now.
 * [oleksii] What would the behavior be for updates?
 * [rob] If we had async support, this could allow extensions to do some kind of handover from the old to the new scripts.
 * [tomislav] Do you do that now? Handoff between old and new content scripts?
 * [oleksii] We try to. Another use case – if the background is suspended, ports are disconnected. No way to know why the port was closed.
 * [rob] In the interest of time, suggest we move on.


#### [Issue 763](https://github.com/w3c/webextensions/issues/763): Proposal: Add topFrameMatches / excludeTopFrameMatches

 * [carlos] Trying to gauge interest in browser support for a proposal.
 * [timothy] I changed our position to supportive.
 * [devlin] We'd go with matches for permissions; topFrameMatches would only be a condition, not part of permissions.
 * [timothy] I'd like to be consistent, top vs main.
 * [rob] main_frame is only in webRequest/declarativeNetRequest.
 * [carlos] We don't currently have top beyond web APIs.
 * [rob] My preference is top. We extend the web platform and would prefer to stay with those conventions.
 * [devlin] Also prefer top, but because we have had cases where there are multiple main frames: portals. They're gone, but they existed.
 * [rob] Can you support origins vs. full paths?
 * [tomislav] Why not full paths?
 * [rob] Leaks information. And full URL may not be available in the process in cross-origin situations.
 * [devlin] Origins make sense. Both process availability and matching on paths is weird. Trying to think of cases where you might want to match on top frame path.
 * [rob] Maybe situations where a username is part of the path, but don't think we can support them.
 * [devlin] Do we have a concern with matching by origins?
 * [rob] Chrome already supports location.ancestorOrigins, which already offers the information. Firefox does not offer that API out of information leakage concerns (privacy).
 * [devlin] Top frame condition where the top frame injects, content script knows the parent is the top frame, then we leak information about what that top frame is.

   If you have a content script that runs on foo.com, and you have the condition that you want to match on foo.com when it's on example.com, injecting the script on foo.com leaks information about the fact that you're on example.com. Didn't realize that ancestor origins already leaks this.
 * [krzysztof] Is this a realistic concern?
 * [rob] On the web leaking origins has privacy implications, with extensions one can do worse.
 * [krzysztof] That's more meaningful on the web than in extensions.
 * [devlin] Attack that might be more concerning is around intranet resources. An extension could extract information about the internal network topology. Acknowledge that domains are not super secret.
 * [carlos] Stick with origins, should we use a different name?
 * [timothy] Would prefer to stick to match patterns and document/enforce that the path is not used.
 * [rob] Technically we could support paths with same-origin contexts.
 * [devlin] Should stick with matches. An origin has a scheme, host and port.
 * [carlos] Any browser willing to implement and sponsor?
 * [timothy] I'm supportive, not a priority to implement.
 * [rob] Implementation is probably easy, unit tests are the more time-consuming part.
 * [carlos] If I create a proposal doc, would –
 * [devlin] Don't think we're ready for a proposal as we don't have a sponsoring browser.
 * [rob] What do we do with cases where we're willing to accept patches, but we don't have time to implement?
 * [simeon] Use a label
 * [tomislav] “patches welcome”
 * [oleksii] Welcome by whom?
 * [rob] That's indicated by the supportive label, right? There are a number of cases where we'd need this.
 * [devlin] Would be useful to enumerate the sources where this would need to be supported. Should ignore paths in match patterns. Should document that this leaks origins and we're okay with it.
 * [rob] (looking at Carlos) If you want to do the implementation I am willing to mentor.
 * [timothy] Same.
 * [carlos] ralph_im_in_danger.gif
 * **Resolution:** Supportive of matching by origins (issue 763). Firefox/Safari willing to mentor external contributions and be the sponsoring browser in that case
